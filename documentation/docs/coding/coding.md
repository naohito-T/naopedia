# コーディング(program)
[新人プログラマに知ってもらいたいメソッドを読みやすくするいくつかの原則](https://qiita.com/hirokidaichi/items/c9a76191216f3cc6c4b2)  
[プログラミング英語検定(これみれば変数名とか付けられる)](https://progeigo.org/learning/essential-words-600-plus/)

## コーディング速度をあげるコツ

コーディング速度を上げる一番の考え方は**迷いをなくすこと。**

## ソフトウェアを作成するときに心掛けること

- エラーハンドリング
- 冪等性の考慮

## 共通化したい時の考え方

共通化したい時のTips
- 一階層上を作りwrapする
- カリー化で適用する
- abstractで共通処理を抜き出す

## マジックナンバーをやめる

number or stringどちらもやめるべき

## コメントの書き方
[アンチプラクティスから学ぶ洗練されたコメントの書き方](https://next.rikunabi.com/journal/20131216_t21_iq/)

変数名/クラス名/関数名で明白なことは書かない。

コミュニケーションでの理論で**グライスの公理（Grice’s Maxims）**というのがある。  
円滑なコミュニケーションが満たすべき4つの条件を説明している。

- 量の公理（Maxim of Quantity）: 情報を過不足なく提供する。
- 質の公理（Maxim of Quality）: 根拠のないことを述べない。嘘をつかない。
- 関係性の公理（Maxim of Relation）: 関係のないことは述べない。
- 様式の公理（Maxim of Manner）: 簡潔に理路整然と述べる。

上記をコメントに落としてみる
以下のようなコメントは、グライスの公理に反しているものが多く、ソースコード上の円滑なコミュニケーションを阻害する。
- 量の公理に違反: コメントを書きすぎている/コメントが説明不足
- 質の公理に違反: コメントが間違っている
- 関係性の公理に違反: コードと関係のないコメント
- 様式の公理に違反: ストレートではなく、まわりくどい、曖昧なコメント

それぞれについて見てみる。

###  量の公理に違反

それぞれのステップでコメントを書くことは、あまり推奨されていない。
書きすぎると量の公理に違反する。ステップにコメントが多い場合は**変数名や関数の切り出し・クラスの分割など検討すること。**


## 良いプログラマーと悪いプログラマーのコメント意識

>良いプログラマーは
>少数の本当に優れたコメントを書くように務める
>理由を説明するコメントを書く
>大量のコメントを書くことよりも、優れたコードを書くことのほうに集中する
>理にかなった有用なコメントを書く

>悪いプログラマーは
>優れたコメントとそうでないコメントの違いがわからない
>方法を説明するコメントを書く
>コメントが自分以外には理解できないものであっても気にしない
>不適切なコードを支える目的で多数のコメントを書く
>ソースファイルに冗長な情報(改版履歴など)を大量に盛り込む

---

## 正規表現でvscodeを検索する

正規表現を普段から使えるようにするための特訓として、vscodeの検索で使う。
ゲームのランタイムで正規表現を使わないとのこと（負荷が高いパターンなどあるため）

## 関数を作るのも、クラスを作るのも関心の分離を考えるべき

アプリケーションを3層に分けたとき（プレゼンテーション・ビジネスロジック・データアクセス）をベースに考えるとわかりやすい
ビジネスロジックをデータアクセスと切り離すというのは保存先がファイルだろうと、RDBだろうとドキュメントDBだろうと、保存ができるようにする。

ようは、ビジネスロジックは限定してはいけない（要は保存をかける時にはバリデーションや整形などすべてを気にしなくて良くする）

## applicationのレイヤーでパラメーターについて考えるのは良くないので、

status: TicketStatus[]
にして、
handler側でパースしてしまうのがいいかと思います！
バリデーションはなるべく上の層でしてしまうのがいい。
→なるべく早めにバリデーションへかけてしまうことでサーバの負荷も下がるため

## コードは今必要なものだけをかく

汎用性よりも単純性を考える。汎用性のもたらす再利用性や拡張性よりも**まずは使えることに価値を置く**
このパラメーター将来必要だろうとするよりも、今必要な機能の作成に時間をさく

## 新規の関数を作成するとき、共通処理がないか探す

関数の中で呼び出している処理が、他の関数でも同様の処理がある場合は二重管理となる。
そのため共通の処理として切り出せないか模索する

## 新規のクラスを作成するとき、共通のプロパティ・メソッドがあるのであればそれを base として切り出して抽象クラスやインターフェイスなどで切り出すことができないか考える

新規のクラスを作成するとき、共通のプロパティ・メソッドがあるのであればそれをbaseとして切り出して抽象クラスとして作成し、違うクラスを2つ作る。

## 参考演算子を使用してもより単純な選択肢が存在しているかもと考える

[参考URL](https://eslint.org/docs/rules/no-unneeded-ternary)

## メモ化を考える

メモ化はNextの`<Script>`タグがわかりやすい
[参考URL](https://zenn.dev/aiji42/articles/9a6ab12ab5f6e6)

### メモ化とは

[railsメモ化](https://qiita.com/kt215prg/items/3c0fd89468dcfe6075df)

メソッドが最初に呼び出された時、戻り値がキャッシュされそれ以降同じスコープ内でメソッドが呼び出されるたびにキャッシュされた値が返されることを意味する

メモ化とは同じ結果を返す処理について、初回のみ処理を実行記録しておき値が必要になった2回目以降は、**前回の処理結果を計算することなく**呼び出し値を得られるようにすること。


イベントハンドラーのようなcallback関数をメモ化し、不要に生成される関数インスタンスの作成を抑制、再描画を減らすことにより、都度計算しなくて良くなることからパフォーマンスを向上が期待できる

**わかりやすく**
関数はオブジェクトなのでプロパティを持てる。
そのプロパティにその関数の結果を格納しておけば、毎回計算しなくても値として格納しているものを読み込むだけのため速度が速くなるよね。ということ。

[メモ化参考 JS](https://qiita.com/syakegon/items/b9ef4c4c91bfd607c771)

## メモ化とシングルトンの違い

シングルトンとメモ化は異なる概念であり、使用する場面や目的が異なります。

シングルトンは、アプリケーション内で一つのインスタンスを共有するためのデザインパターンです。特定のクラスのインスタンスが必要な場所で、常に同じインスタンスを取得できるようにします。シングルトンは、リソースの共有や状態の保持が必要な場合に有用です。

一方、メモ化は計算結果を一時的に保存し、同じ引数で再度呼び出された場合にキャッシュから結果を返す手法です。メモ化は再計算のコストを削減し、パフォーマンスの向上を図るために使用されます。特に計算結果が不変であることがわかっている場合や、再計算が高コストである場合に有効です。

シングルトンとメモ化は目的が異なるため、どちらが良いかは使用する場面や要件によります。シングルトンはクラスのインスタンスの共有や状態管理が必要な場合に適しており、メモ化は計算結果の再利用やパフォーマンスの向上が必要な場合に適しています。

---

これはTBD（To Be Determined）: 未定、未確定

- コードの省略ができるか考える（ファイル量を減らす目的）
※しかし極端な省略はチームによっては受け入れられない。

- ペラ1でコードを記載しているのであれば、envなどに定数は分けるべき。またconfigファイルなどに分けれるのか検討する。

- 値が返ってく前提で書いているのがいけない(常にundefained)が返ってくる or nullの可能性を示唆するべき

- 最近は文字列連結の中で変数確認する人はいなくなった(これは必要に応じてって感じ)

## 後で別ファイルに

## 抽象クラスとは

抽象クラスを継承したサブクラスは、抽象クラスにある抽象メソッドのオーバーライド必須
サブクラスでコンストラクタを記述しなければならない
直接インスタンス化できない
多重継承はできない

>象クラスを実装するメリットは、抽象クラスの特徴１に書いた、"抽象クラスを継承したサブクラスは、抽象クラスにある抽象メソッドを必ずオーバーライドしなければならない"です。
複数人で開発を行う場合に実装レベルのルールを作れる！です。

## 抽象クラスとインターフェースの違い

言語によるが、抽象クラスの多重継承を禁止していることが多い。
上記を踏まえると、抽象クラスは結合度が高くなる(実装するべきmethodなども多い)
その点、interfaceは実装の責任を課す部分もあるが、多重継承も可能のためファイル分割も可能となる。


## メモ化とは

メモ化とは同じ結果を返す処理について、初回のみ処理を実行記録しておき、値が必要となった2回目以降は前回の処理結果を計算することなく呼び出し値を得られるようにすること。

## 分岐アンチパターン

[参考URL](https://qiita.com/pakkun/items/9bef9132f168ba0befd7)

大事なこと
- 否定の否定は回避する(変数名の代入先と代入部分に着目しろ)
- 基本的に変数名は肯定で記述しよう


```php
// アンチパターン
$delete_off = false;
// 両方、否定の否定になっている

// 対策
$delete_on = true

```


## コーディング規約

コーディング規約は多数のプログラマが参加するプロジェクトにおいて、プログラミング品質を均等にするために定める文書

メンバーのスキルが高い場合は、コーディング規約はできるだけ薄い方が良い。高スキル者に色々規約を守らせようとすると生産性が大幅に落ちてしまい高スキル者を集めた意味がない。

## 再生 vs 再認

認知心理学では、2つの記憶のモード、再生と再認を考える。

- 再生
再生は過去の記憶を何もインプットがなくても思い出せる状態。
- 再認
これは体験したことがありますか？と問われてたらああ、これは体験したことがあると思い出せる状態。

## 再生するには？

再生をするには完全に完全に記憶しきっている状態にならないとダメ。
慣れている人は、数多くのパターンを記憶しておりそれを再生することでコードが書ける。他の人のコードを見たときにも過去のパターンと照らし合わせてよりよいコードパターンを思いついたりする。

**再認の方が難易度は低い。**ドキュメント、サンプルコード、ネットで調べた情報などを辿りながら、それを組み合わせて実装します。時間もかかりますし、**検索で出てこないパターンだとパフォーマンスが落ちる。**
ですが、なんどもなんどもコードを見て繰り返し再認していくと、再生でコードが書けるようになります。このドキュメントは再認の効率アップがゴールです。

とはいえ、必ずしも全員が再生レベルになる必要はありません。たとえGoに慣れていても、普段使わないパッケージ（cryptoパッケージの暗号化とか）を使う場合は再認で（サンプルのコピペで）コードを書くことになるでしょう。上級者でも、自分用のスニペット集を作ることで、記憶の能力の節約しつつパフォーマンスは落とさないということをしますね。


## コーディングを書き始める前に念頭においておくもの

1. 仕様は確認したか？ビジネス要件 & サイトの機能、役割がわかっていないと全体像を見通せない。
そのため全体像を把握していることを考える。
2. コードを書き始める前にコメントでその処理をやることを考える。


## 同じことを繰り返すな（Don't Repeat Yourself: DRY）: DRY

ソフトウェア開発上の原則であり「システムを構成する知識のあらゆる部品は、常に単一であり、明確であり、信頼できる形で表現されていなければならない」というもの。
同じコードを繰り返し書くことを徹底的に避けることで、コードが保守しやすくなり、容易に拡張できるようになり、そして何よりバグを減らすことができる。

設定より規約が優先（Convention Over Configuration）: Railsでは、Webアプリケーションで行われるさまざまなことを実現するための最善の方法を明確に思い描いており、Webアプリケーションの各種設定についても従来の経験や慣習を元に、それらのデフォルト値を定めています。このようにある種独断でデフォルト値が決まっているおかげで、開発者の意見をすべて取り入れようとした自由過ぎるWebアプリケーションのように、開発者が延々と設定ファイルを設定して回らずに済みます。

## 論理演算を考えろ(ドモルガンの法則)

```js
!(P || Q) == !P && !Q
!(P && Q) == !P || !Q

const hasUserLicense = !(isSubscriptionFailed.value || isWaitingKonbiniCharge.value);
```
[ドミルガンの法則](https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%BB%E3%83%A2%E3%83%AB%E3%82%AC%E3%83%B3%E3%81%AE%E6%B3%95%E5%89%87)

## switch 文

スタイルシート系は抜いて、
網羅できていないものはいい。

switch文では文字を返してはいけない返すのは変数
なぜなら変数を返すだけなら変更の影響は少ないから

そして上司にはこう言える
documentを変えたダケのためテストは入りません。
プログラムの動作は変更がないためテストは不要だろう？という話

## if文を減らすには


## 真偽値

[参考URL](https://qiita.com/yskszk/items/5a7f99c974773f03a82a)


## オーバーロード

**メリット**
オーバーロードを使う場合、同じような機能で引数にint型とdouble型がある場合でもメソッド名は同じ。
そのため、**メソッドを使う人は引数の型を気にする必要がない**
このようにオーバーロードを使うことで、メソッドを使う人が "引数の型を意識せずに使える"というメリットがありま
す。
オーバーロードが使われている身近な例のひとつに「System.out.println()」があります。printlnメソッドは、int, double, Stringなど引数の型が違っても同じメソッド名で使用できますよね。
このように、オーバーロードすれば引数によってメソッドの名前を少しずつ変更する必要がなく、メソッド名を覚える必要もなくなる、などさまざまなメリットがあります。

**デメリット**
オーバーロードの使い方によってはデメリットも存在します。
たくさんオーバーロードしすぎた場合、プログラムの理解がしにくく管理が難しくなってしまいます。またしっかりと設計しないと、同じ名前でもばらばらの処理を行うメソッドが生まれてしまったりして、混乱を招いてしまうこともあるでしょう。
オーバーロードは便利ですが、何にでも使えばいいわけではありません。必要なところを見極めて使用しましょう。

## 配列から重複要素を取り除く

「Setに渡した値は重複しない」という特性を使って、配列から値が重複する要素を取り除く処理に応用できる。

## エラーハンドリング

エラーハンドリングとして、その言語で標準に設定されているものや
```ts
const hello = () => {
  throw new Error();
}
```

その言語のErrorインターフェイスを満たした独自の型を定義する方法がある。

## 世界対応なのか日本対応なのか

[タイムゾーンの意識](https://blog.studysapuri.jp/entry/2016/12/05/090000)


```
Time.zone = 'UTC'
Time.zone.now
# => Thu, 04 Feb 2016 10:00:00 UTC +00:00

Time.use_zone('Asia/Tokyo') { Time.zone.now }
# => Thu, 04 Feb 2016 19:00:00 JST +09:00
```

## エラーメッセージは見ろ

しっかりみて検索する力を、GitHubのissueとか探せ 

## 変数名を考える

[参考URL](https://blog.77jp.net/guidelines-for-variables-and-method-names-summary)

## スカラー型

スカラーとは単一の値のことを示しています。
単一の値ということは複合的なデータではないということです。
つまり、プログラマーにとってわかりやすい単語を使うなら、複数のデータを扱う配列やハッシュはスカラーではありません。

[参考URL](https://ja.stackoverflow.com/questions/41164/%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC-%E3%81%A8-%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96-%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)


## アノテーションコメント

[参考URL](https://blog.shitake4.tech/entry/2017/10/03/%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%A7%E8%A6%8B%E3%82%8BTODO%E3%81%A3%E3%81%A6%E4%BD%95%EF%BC%9F)

Rubyのstyle guideから
Rubyではコードの中からアノテーションコメントを見つけるライブラリがある。

```ts
// TODO: 後で追加すべき内容を表す
// FIXME: 修正すべき箇所を表す
// OPTIMIZE: パフォーマンスの最適化をすべき箇所を表す
// HACK: リファクタリングすべき箇所を表す
// REVIEW: レビューすべき箇所を記す
```

## 配列と連想配列

[参考URL](https://qiita.com/raccy/items/816a322fb330193e788b)

配列は単なる値の順列と考えられる。
>値が一つ一つ順番に並んでおり、入っている値の数(同じオブジェクトが重複して入っている場合もある)がその配列の長さであり、0または1から始まるインデックスでアクセスできるというものです。複数のオブジェクトをひとまとめに扱う場合、この単純な配列であってもそれなりに使用できますが、インデックスは整数しか使えず、飛び飛びに使うことはできず1、ある値を探すには順番に見に行くしかないなど、色々と不便なところがあります。そこで、インデックスに任意の名前をつけて、目的の値をすばやく取得できるようにしたのが連想配列です。

## ソフトウェア的 ConfigとSettingの違い

[参考URL](https://jp.quora.com/config-to-setting-no-chigai-ha-nani-desu-ka)

粒度が違うのは少しわかる。
>Configurationは、何かシステムの深く基礎的な属性として感じ取る。
>Preferenceは、モノサシの反対側の端に置くと思う。
>SettingとかOptionというコトバもあって、そこらへんはどちらでも構わないただし文脈内での一貫性は保ちつつ）
>Propertiesは大概オブジェクトやアイテムを参照して使うコトバ（例えばグラフィックプログラムにおける画像など）
>まとめて例示すると、自分がシステムを設計するとして、インストール中に利用者や顧客に設定させるのがConfiguration。（それが済んで）個々のユーザに表面的なことについて独自の選択をさせるためにPreferenceメニュを用意することだろう。で、そのPreferenceの中には山ほどのsettingやoptionが束になってる。何かのオブジェクトを右クリックしたりすると、そのオブジェクトの特徴的な性質を変更するためにPropertiesの変更権を得る。
>ただし、最終的には、用語についても、ソフトウェアの他の作り物と同じようにテストすること。こういった呼称については、業種ごとに極めて特徴的な習慣が、まま、ある。柔軟に考えて、混乱を生む要素については直すこと。

管理者権限でいじるのがconfig
ユーザー権限でいじるのがsettings

## モデルについて

モデルのファイル名やファイル内のモデル名は単数が基本。
モデルを単数にするとテーブル名をmembersのように複数形、モデルのクラス名は単数形のMember、クラスを記述するファイル名はmember.rbとなる。

## 循環参照

[参考URL](https://qiita.com/gazf/items/5c2a082e3cd3d85b4a10)  

## 重複を取り除く

言語によって変わるが、配列などをSetにかまして重複を取り除くっていうのはいわゆるテクニック。

## Set

Setは**特定の要素を出し入れするような用途には適していない。**
一般的にSetを利用するのは、ある値がすでに存在しているか（=サブセット）など集合関係に関心がある場合に使用する。

## DDD
[参考URL](https://neos21.net/blog/2021/10/13-01.html)

## 関数型プログラミング


# tips

codingの普遍的なTipsを記録する

## 連想配列と配列

基本的に配列は前から順番に検索するため時間がかかる。
連想配列はインデックスを貼るため検索が早くなる。

## enum

大体の言語が`boolean`・`string`・`integer`を提供している。  
表現する個数が少ない場合などは`integer`で表現するのはありだと思う。
4つぐらいから文字列で定義したほうがいいかも

## 配列操作

- 配列からランダムに値を取得


- 任意の要素数の配列を作る方法
[参考URL](https://ginpen.com/2018/12/10/create-array-with-specified-length/)

- 配列・多次元配列からランダムに値を取得する方法
[参考URL](https://1-notes.com/javascript-get-values-randomly-from-an-array/)

考えること
用は配列の中身をランダムに取得すれば良い話。
index部分をランダムにする
`Xxx[n~nx]`

## Tips

- Math.floor()
与えられた数値以下の最大の整数を返す。
```js
console.log(Math.floor(5.95));
// expected output: 5

console.log(Math.floor(5.05));
// expected output: 5

console.log(Math.floor(5));
// expected output: 5
```

- Math.random()
0以上1未満（0は含むが、1は含まない）の範囲で浮動小数点の擬似乱数を返す
```js
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

console.log(getRandomInt(3));
// expected output: 0, 1 or 2

console.log(getRandomInt(1));
// expected output: 0

console.log(Math.random());
// expected output: a number from 0 to <1
```


## ユースケース

なんらかの目的を達成するために行われるユーザとアプリケーションの間の一連のやり取りを表したものです

## EntityとModelの違い

一般的なソフトウェア開発の文脈では、"Entity"と"Model"は異なる概念を指します。

エンティティ（Entity）は、データベース内の特定のテーブルやコレクションに相当するものです。エンティティはデータベースの実際の構造に基づいて定義され、特定のデータベーステーブルの行（レコード）に対応することがあります。エンティティは通常、データベーススキーマ内の列（フィールド）と1対1または1対多の関係を持ちます。エンティティはデータベースからのデータの永続化や取得を担当する場合もあります。

一方、モデル（Model）は、アプリケーション内で使用されるデータの構造や振る舞いを表現するために使用されます。モデルはエンティティや他のデータソースからのデータを抽象化し、アプリケーションのビジネスロジックや操作に関連するメソッドやプロパティを提供します。モデルはアプリケーションのロジックやビューに関連する機能を持ち、データの整形やバリデーション、操作の実行などを行います。

要約すると、エンティティはデータベースのテーブルやコレクションに対応し、データベースの永続化やデータの取得を扱います。一方、モデルはアプリケーションのデータの構造や振る舞いを表現し、アプリケーションのロジックやビューに関連する操作を提供します。モデルは通常、エンティティからのデータの変換や加工を担当しますが、エンティティとモデルの具体的な役割や関係はプロジェクトやアーキテクチャによって異なる場合もあります。
