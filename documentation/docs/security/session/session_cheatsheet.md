# Session cheatsheet

[Session_Management_Cheat_Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)

## セッション管理チートシート（翻訳しただけ）

### 導入

Web認証、セッション管理、アクセス制御
Webセッションとは、同じユーザーに関連付けられたネットワーク HTTP 要求と応答のトランザクションのシーケンスです。  
最新の複雑な Web アプリケーションでは、複数の要求が続く間、各ユーザーに関する情報やステータスを保持する必要があります。そのため、セッションでは、アクセス権やローカリゼーション設定などの変数を確立する機能が提供されます。これらの変数は、セッションの期間中、ユーザーが Web アプリケーションと行うすべてのやり取りに適用されます。

Web アプリケーションは、最初のユーザー リクエストの後に匿名ユーザーを追跡するためのセッションを作成できます。たとえば、ユーザーの言語設定を維持する場合などです。さらに、Web アプリケーションは、ユーザーが認証されるとセッションを使用します。これにより、後続のリクエストでユーザーを識別できるだけでなく、セキュリティ アクセス制御、ユーザーのプライベート データへの承認済みアクセスを適用し、アプリケーションの使いやすさを向上させることができます。したがって、現在の Web アプリケーションは、認証前と認証後の両方でセッション機能を提供できます。

認証されたセッションが確立されると、セッション ID (またはトークン) は、ユーザー名とパスワード、パスフレーズ、ワンタイム パスワード (OTP)、クライアント ベースのデジタル証明書、スマート カード、または生体認証 (指紋や目の網膜など) など、アプリケーションで使用される最も強力な認証方法と一時的に同等になります。OWASP認証チート シートを参照してください。

HTTP はステートレス プロトコル ( RFC2616セクション 5) であり、各リクエストとレスポンスのペアは他の Web のやり取りから独立しています。したがって、セッションの概念を導入するには、Web アプリケーションで一般的に使用できる認証モジュールとアクセス制御 (または承認) モジュールの両方をリンクするセッション管理機能を実装する必要があります。

## セッションダイアグラム

セッション ID またはトークンは、ユーザー認証資格情報 (ユーザー セッションの形式) を、ユーザー HTTP トラフィックおよび Web アプリケーションによって適用される適切なアクセス制御にバインドします。最新の Web アプリケーションにおけるこれら 3 つのコンポーネント (認証、セッション管理、アクセス制御) の複雑さ、および実装とバインドが Web 開発者の手に委ねられているという事実 (Web 開発フレームワークはこれらのモジュール間の厳密な関係を提供しないため) により、安全なセッション管理モジュールの実装は非常に困難になっています。

セッション ID の開示、キャプチャ、予測、ブルート フォース、または固定は、セッション ハイジャック (またはサイドジャック) 攻撃につながり、攻撃者は Web アプリケーションで被害者のユーザーを完全に偽装できます。攻撃者は、標的型と汎用型の 2 種類のセッション ハイジャック攻撃を実行できます。標的型攻撃の場合、攻撃者の目的は、特定の (または特権を持つ) Web アプリケーションの被害者のユーザーになりすますことです。汎用攻撃の場合、攻撃者の目的は、Web アプリケーションで任意の有効または正当なユーザーになりすます (またはアクセスする) ことです。

## セッションIDプロパティ
認証された状態を維持し、Web アプリケーション内でのユーザーの進行状況を追跡するために、アプリケーションは、セッション作成時に割り当てられ、セッション期間中にユーザーと Web アプリケーションによって共有および交換されるセッション識別子(セッション ID またはトークン) をユーザーに提供します (セッション ID は、すべての HTTP 要求で送信されます)。セッション ID はペアですname=value。

安全なセッション ID を実装するためには、識別子 (ID またはトークン) の生成が次のプロパティを満たす必要があります。

セッションID名のフィンガープリンティング¶
セッション ID で使用される名前は、過度に説明的なものや、ID の目的や意味について不必要な詳細を提供するものであってはなりません。

最も一般的な Web アプリケーション開発フレームワークで使用されるセッション ID 名は、(PHP)、(J2EE)、( ColdFusion )、 (ASP .NET)など、簡単にフィンガープリントできます。したがって、セッション ID 名から、Web アプリケーションで使用されるテクノロジとプログラミング言語が明らかになる可能性があります。PHPSESSIDJSESSIONIDCFIDCFTOKENASP.NET_SessionId

Web 開発フレームワークのデフォルトのセッション ID 名を、 などの一般的な名前に変更することをお勧めしますid。

## セッションIDの長さ
セッション ID は、ブルート フォース攻撃 (攻撃者が ID 値の全範囲を調べて有効なセッションの存在を確認できる) を防ぐのに十分な長さである必要があります。

セッション ID の長さは少なくとも である必要があります128 bits (16 bytes)。

注記：

128 ビットのセッション ID の長さは、次のセクション「セッション ID エントロピー」で行われた仮定に基づいて参考として提供されています。ただし、他の実装要因がその強度に影響を与える可能性があるため、この数値は絶対的な最小値として考慮されるべきではありません。
たとえば、Microsoft ASP.NET セッション IDなどのよく知られた実装があります。「ASP .NET セッション ID は、a から z までの小文字と 0 から 5 までの数字で構成される 24 文字の文字列にエンコードされた、ランダムに生成された数値です。」
非常に優れた有効エントロピーを提供できるため、推測やブルート フォース攻撃を回避するのに十分な長さであると考えられます。
セッションIDエントロピー¶
攻撃者が統計分析技術を使用して有効なセッションの ID を推測または予測できる推測攻撃を防ぐために、セッション ID は予測不可能 (十分にランダム) である必要があります。この目的のために、優れたCSPRNG (暗号的に安全な疑似乱数ジェネレーター) を使用する必要があります。

セッション ID 値は少なくとも64 bitsエントロピーを提供する必要があります (適切なPRNGが使用されている場合、この値はセッション ID の長さの半分になると推定されます)。

さらに、ランダムなセッション ID だけでは不十分です。重複した ID を避けるために、セッション ID は一意である必要があります。ランダムなセッション ID は、現在のセッション ID スペースに既に存在してはなりません。

注記：

セッション ID エントロピーは、Web アプリケーションに一般的に存在する同時アクティブ セッションの数、絶対セッション有効期限のタイムアウト、攻撃者が 1 秒あたりに実行できるセッション ID 推測の数、およびターゲット Web アプリケーションがサポートできるセッション ID 推測の数など、他の外部の測定が難しい要因によって実際に影響を受けます。
エントロピーが のセッション ID64 bitsが使用される場合、Web アプリケーションで 100,000 の有効な同時セッションが利用可能で、攻撃者が 1 秒あたり 10,000 回の推測を試みることができると仮定すると、攻撃者は有効なセッション ID を推測するのに 292 年以上かかることが予想されます。
詳細はここをご覧ください。
セッション ID の内容 (または値)¶
情報漏洩攻撃を防ぐために、セッション ID の内容 (または値) は無意味である必要があります。情報漏洩攻撃では、攻撃者が ID の内容をデコードし、ユーザー、セッション、または Web アプリケーションの内部動作の詳細を抽出できます。

セッション ID はクライアント側の単なる識別子である必要があり、その値には機密情報や個人を特定できる情報 (PII) を含めることはできません。PII の詳細については、Wikipediaまたはこの投稿を参照してください。

セッション ID に関連付けられた意味とビジネス ロジックまたはアプリケーション ロジックは、サーバー側、具体的にはセッション オブジェクトまたはセッション管理データベースまたはリポジトリに保存する必要があります。

保存される情報には、クライアント IP アドレス、ユーザー エージェント、電子メール、ユーザー名、ユーザー ID、ロール、権限レベル、アクセス権、言語設定、アカウント ID、現在の状態、最終ログイン、セッション タイムアウト、その他の内部セッションの詳細が含まれます。セッション オブジェクトとプロパティにクレジットカード番号などの機密情報が含まれている場合は、セッション管理リポジトリを適切に暗号化して保護する必要があります。

言語またはフレームワークによって作成されたセッション ID を使用することをお勧めします。独自のセッション ID を作成する必要がある場合は、少なくとも 128 ビットのサイズの暗号的に安全な疑似乱数ジェネレーター (CSPRNG) を使用して、各セッション ID が一意であることを確認してください。

セッション管理の実装¶
セッション管理の実装は、ユーザーと Web アプリケーションの間でセッション ID を共有し、継続的に交換するために使用される交換メカニズムを定義します。Web アプリケーション内でセッション状態を維持するために、HTTP には、Cookie (標準 HTTP ヘッダー)、URL パラメーター (URL 書き換え - RFC2396 )、GET 要求の URL 引数、POST 要求の本文引数 (隠しフォーム フィールド (HTML フォーム) など)、独自の HTTP ヘッダーなど、複数のメカニズムが用意されています。

推奨されるセッション ID 交換メカニズムでは、トークンの有効期限や時刻、細かい使用制限などの高度なトークン プロパティを定義できる必要があります。これが、Cookie (RFC 2109、2965、6265) が最も広く使用されているセッション ID 交換メカニズムの 1 つであり、他の方法では利用できない高度な機能を提供する理由の1つです。

ID が URL に含まれているような特定のセッション ID 交換メカニズムを使用すると、セッション ID が (Web リンクやログ、Web ブラウザーの履歴やブックマーク、Referer ヘッダー、検索エンジンなどで) 公開される可能性があり、また、ID の操作やセッション固定攻撃などの他の攻撃も容易になる可能性があります。

組み込みセッション管理実装¶
J2EE、ASP .NET、PHP などの Web 開発フレームワークは、独自のセッション管理機能と関連する実装を提供します。これらの組み込みフレームワークは世界中の複数の Web 環境で使用されており、Web アプリケーションのセキュリティおよび開発コミュニティによって長年にわたってテストされているため、自作のフレームワークをゼロから構築するのではなく、これらの組み込みフレームワークを使用することをお勧めします。

ただし、これらのフレームワークは過去に脆弱性や弱点も抱えていることに留意してください。そのため、既知の脆弱性がすべて修正されている可能性のある最新バージョンを常に使用し、このドキュメントに記載されている推奨事項に従ってデフォルト構成を確認して変更し、セキュリティを強化することをお勧めします。

セッション ID を一時的に保存するためにセッション管理メカニズムによって使用されるストレージ機能またはリポジトリは、ローカルまたはリモートでの偶発的な漏洩や不正アクセスからセッション ID を保護するために安全である必要があります。

使用されるセッション ID 交換メカニズムと受け入れられるセッション ID 交換メカニズム¶
Web アプリケーションは、セッション ID 交換管理に Cookie を使用する必要があります。ユーザーが URL パラメータなどの別の交換メカニズムを使用してセッション ID を送信した場合、Web アプリケーションはセッション固定を阻止する防御戦略の一環として、その ID を受け入れないようにする必要があります。

注記：

Web アプリケーションがデフォルトのセッション ID 交換メカニズムとして Cookie を使用する場合でも、他の交換メカニズムも受け入れる場合があります。
したがって、セッション ID を処理および管理する際に、Web アプリケーションが現在受け入れているさまざまなメカニズムをすべて徹底的にテストして確認し、受け入れられるセッション ID 追跡メカニズムを Cookie だけに制限する必要があります。
過去には、一部の Web アプリケーションでは、特定の条件 (たとえば、Cookie をサポートしていない Web クライアントの識別や、ユーザーのプライバシーに関する懸念から Cookie を受け入れないなど) が満たされた場合、URL パラメータを使用したり、Cookie から URL パラメータに切り替えたり (自動 URL 書き換えによって) していました。
トランスポート層セキュリティ¶
ネットワーク トラフィックでの能動的な盗聴や受動的な漏洩からセッション ID 交換を保護するには、ユーザー資格情報が交換される認証プロセスだけでなく、Web セッション全体で暗号化された HTTPS (TLS) 接続を使用することが不可欠です。これは、クライアントがサポートしているHTTP Strict Transport Security (HSTS)によって軽減される可能性があります。

さらに、セッション ID が暗号化されたチャネルを通じてのみ交換されるようにするには、 Secure Cookie 属性を使用する必要があります。暗号化された通信チャネルを使用すると、攻撃者が Web トラフィックを傍受して操作し、被害者の Web ブラウザにセッション ID を挿入 (または修正) するセッション固定攻撃からセッションを保護することもできます (こちらとこちらを参照)。

次のベスト プラクティス セットは、セッション ID (特に Cookie が使用される場合) を保護し、Web アプリケーション内での HTTPS の統合を支援することに重点を置いています。

特定のセッションを HTTP から HTTPS に、またはその逆に切り替えないでください。切り替えると、セッション ID がネットワークを通じて暗号化されずに公開されます。
HTTPS にリダイレクトする場合は、リダイレクトが発生した後にCookie が設定または再生成されることを確認します。
同じページ内または同じドメイン内の暗号化されたコンテンツと暗号化されていないコンテンツ (HTML ページ、画像、CSS、JavaScript ファイルなど) を混在させないでください。
可能であれば、同じホストから暗号化されていない公開コンテンツと暗号化された非公開コンテンツを提供することは避けてください。安全でないコンテンツが必要な場合は、別の安全でないドメインでホストすることを検討してください。
HTTPS 接続を強制するには、HTTP Strict Transport Security (HSTS)を実装します。
TLS を安全に実装するためのより一般的なガイダンスについては、OWASP Transport Layer Security Cheat Sheetを参照してください。

TLS はセッション ID の予測、ブルート フォース、クライアント側の改ざんや固定に対しては保護を提供しないことを強調しておくことが重要です。ただし、中間者攻撃によってセッション ID を傍受または盗用する攻撃者に対しては効果的な保護を提供します。

クッキー¶
クッキーに基づくセッション ID 交換メカニズムは、セッション ID の交換を保護するために使用できるクッキー属性の形式で複数のセキュリティ機能を提供します。

セキュア属性¶
CookieSecure属性は、Web ブラウザに、暗号化された HTTPS (SSL/TLS) 接続を介してのみ Cookie を送信するように指示します。このセッション保護メカニズムは、MitM (中間者) 攻撃によるセッション ID の漏洩を防ぐために必須です。これにより、攻撃者が Web ブラウザのトラフィックからセッション ID を簡単に取得できなくなります。

Web アプリケーションが通信に HTTPS のみを使用するように強制しても (Web アプリケーション ホストでポート TCP/80、HTTP が閉じられている場合でも)、Cookie がSecure設定されていない場合はセッション ID の漏洩を防ぐことはできません。Web ブラウザは、暗号化されていない HTTP 接続を介してセッション ID を漏洩するように騙される可能性があります。攻撃者は、被害者のユーザー トラフィックを傍受して操作し、Web アプリケーションへの暗号化されていない HTTP 参照を挿入して、Web ブラウザにセッション ID を平文で送信させるように強制することができます。

参照: SecureFlag

HttpOnly 属性¶
cookieHttpOnly属性は、Web ブラウザに、スクリプト (JavaScript や VBscript など) が DOM document.cookie オブジェクトを介して cookie にアクセスできないように指示します。このセッション ID 保護は、XSS 攻撃によるセッション ID の盗難を防ぐために必須です。ただし、XSS 攻撃が CSRF 攻撃と組み合わされた場合、ブラウザはリクエストの送信時に常に cookie を含めるため、Web アプリケーションに送信されるリクエストにはセッション cookie が含まれます。cookie はHttpOnlycookie の機密性のみを保護します。攻撃者は、XSS 攻撃のコンテキスト外で、cookie をオフラインで使用することはできません。

OWASP XSS (クロスサイトスクリプティング) 防止チートシートを参照してください。

参照: HttpOnly

SameSite 属性¶
SameSite は、ブラウザがクロスサイト リクエストで SameSite フラグ付き Cookie を送信するのを防ぐ Cookie 属性を定義します。主な目的は、クロスオリジン情報漏洩のリスクを軽減し、クロスサイト リクエスト フォージェリ攻撃に対する保護を提供することです。

参照: SameSite

ドメインとパス属性¶
cookieDomain属性は、 Web ブラウザに、指定されたドメインとすべてのサブドメインにのみ cookie を送信するように指示します。属性が設定されていない場合、デフォルトでは cookie はオリジン サーバーにのみ送信されます。cookiePath属性は、 Web ブラウザに、Web アプリケーション内の指定されたディレクトリまたはサブディレクトリ (またはパスまたはリソース) にのみ cookie を送信するように指示します。属性が設定されていない場合、デフォルトでは cookie は、要求され cookie が設定されているリソースのディレクトリ (またはパス) にのみ送信されます。

これら 2 つの属性には、狭い範囲または制限された範囲を使用することをお勧めします。この方法では、属性をDomain設定せず (Cookie を元のサーバーのみに制限)、Pathセッション ID を使用する Web アプリケーション パスに属性を可能な限り制限して設定する必要があります。

Domain属性を などの許容度が高すぎる値に設定すると、example.com攻撃者は同じドメインに属する異なるホストや Web アプリケーション間のセッション ID に対して攻撃を仕掛けることができます。これはクロスサブドメイン Cookie と呼ばれます。たとえば、 の脆弱性により、www.example.com攻撃者は からセッション ID にアクセスできる可能性がありますsecure.example.com。

さらに、同じドメイン上でセキュリティ レベルの異なる Web アプリケーションを混在させないことが推奨されます。いずれかの Web アプリケーションに脆弱性があると、攻撃者は、セッション固定攻撃で使用できる手法である permissive 属性(Domainなどexample.com) を使用して、同じドメイン上の別の Web アプリケーションのセッション ID を設定できるようになります。

このPath属性により、同じホスト上の異なるパスを使用する異なる Web アプリケーション間でセッション ID を分離できますが、同じホスト上で異なる Web アプリケーション (特にセキュリティ レベルやスコープが異なるもの) を実行しないことを強くお勧めします。これらのアプリケーションは、オブジェクトなどの他の方法を使用してセッション ID にアクセスできますdocument.cookie。また、どの Web アプリケーションでも、そのホスト上の任意のパスに Cookie を設定できます。

Cookie は DNS スプーフィング/ハイジャック/ポイズニング攻撃に対して脆弱であり、攻撃者は DNS 解決を操作して、Web ブラウザに特定のホストまたはドメインのセッション ID を開示させることができます。

有効期限と最大有効期間の属性¶
クッキーに基づくセッション管理メカニズムでは、非永続的 (またはセッション) クッキーと永続的クッキーの 2 種類のクッキーを使用できます。クッキーがMax-Age( より優先されるExpires) またはExpires属性を提示する場合、そのクッキーは永続的クッキーとみなされ、有効期限まで Web ブラウザによってディスクに保存されます。

通常、認証後にユーザーを追跡するセッション管理機能では、非永続的な Cookie が使用されます。これにより、現在の Web ブラウザー インスタンスが閉じられると、クライアントからセッションが強制的に消えます。したがって、セッション管理の目的では非永続的な Cookie を使用することを強くお勧めします。これにより、セッション ID が Web クライアント キャッシュに長期間残って攻撃者が取得するのを防ぐことができます。

機密情報が永続的に保存されないようにし、暗号化し、必要な期間のみ保存することで、機密情報が漏洩しないようにします。
クッキー操作による不正な活動が行われないようにする
安全でない方法で誤ってネットワーク経由で送信されないように、セキュアフラグが設定されていることを確認します。
アプリケーションコード内のすべての状態遷移が適切にクッキーをチェックし、その使用を強制しているかどうかを確認します。
機密データがクッキーに保存されている場合は、クッキー全体を暗号化する必要があります。
アプリケーションで使用されるすべてのCookie、その名前、および必要な理由を定義します。
HTML5 ウェブストレージ API¶
Web ハイパーテキスト アプリケーション技術ワーキング グループ (WHATWG) は、クライアント側で名前と値のペアを保存するためのメカニズムとして、 HTML5 Web ストレージ APIlocalStorageおよびについて説明しています。HTTP クッキーとは異なり、およびの内容は、ブラウザによる要求または応答内で自動的に共有されず、クライアント側でデータを保存するために使用されます。sessionStoragelocalStoragesessionStorage

ローカルストレージAPI¶
範囲¶
APIを使用して保存されたデータはlocalStorage、同じオリジンから読み込まれたページからアクセスできます。オリジンは、スキーム ( https://)、ホスト ( example.com)、ポート ( 443)、およびドメイン/レルム ( ) として定義されます。これにより、Cookie のフラグをexample.com使用して実現されるのと同様のデータへのアクセスが提供されます。つまり、 から保存されたデータはを介し​​て取得できません。別のウィンドウ/スレッドからの同時アクセスの可能性があるため、 を使用して保存されたデータは共有アクセスの問題 (競合状態など) の影響を受けやすく、非ロックと見なす必要があります ( Web Storage API 仕様)。securehttpshttplocalStorage

間隔¶
APIを使用して保存されたデータはlocalStorageブラウジング セッション全体にわたって保持され、他のシステム ユーザーがアクセスできる期間が延長されます。

オフラインアクセス¶
標準ではlocalStorage保存時にデータを暗号化する必要がないため、ディスクからこのデータに直接アクセスできる可能性があります。

使用事例¶
WHATWG は、複数のウィンドウやタブ、複数のセッションにわたってアクセスする必要があるデータや、パフォーマンス上の理由から大容量 (数メガバイト) のデータを格納する必要がある場合に を使用することを提案してlocalStorageいます。

セッションストレージAPI¶
範囲¶
APIsessionStorageは、呼び出し元のウィンドウ コンテキスト内にデータを保存します。つまり、タブ 1 はタブ 2 から保存されたデータにアクセスできません。また、API と同様にlocalStorage、API を使用して保存されたデータsessionStorageは、スキーム ( https://)、ホスト ( example.com)、ポート ( )、443およびドメイン/領域 ( ) として定義される同じオリジンから読み込まれたページからアクセスできます。これにより、Cookie の フラグexample.comを使用することによって実現されるのと同様のデータ アクセスが提供されます。つまり、 から保存されたデータはを介し​​て取得できません。securehttpshttp

間隔¶
APIsessionStorageは、現在のブラウジング セッションの期間中のみデータを保存します。タブが閉じられると、そのデータは取得できなくなります。ただし、ブラウザ タブを再利用したり開いたままにしたりしても、必ずしもアクセスが妨げられるわけではありません。また、ガベージ コレクション イベントが発生するまで、データがメモリ内に残ることもあります。

オフラインアクセス¶
標準ではsessionStorage保存時にデータを暗号化する必要がないため、ディスクからこのデータに直接アクセスできる可能性があります。

使用事例¶
WHATWG は、チケット予約の詳細など、ワークフローの 1 つのインスタンスに関連するデータに対して、他のタブで複数のワークフローを同時に実行できる場合に を使用することを提案していますsessionStorage。ウィンドウ/タブにバインドされた性質により、別々のタブのワークフロー間でデータが漏洩することはありません。

参考文献¶
ウェブストレージAPI
ローカルストレージAPI
セッションストレージ API
WHATWG Web ストレージ仕様
ウェブワーカー¶
Web Workers は、現在のウィンドウとは別のグローバル コンテキストで JavaScript コードを実行します。メイン実行ウィンドウとの通信チャネルが存在し、これを と呼びますMessageChannel。

## 使用事例

Web Workers は、ページの更新後もストレージの永続性が要求されない場合に、ブラウザーに (セッション) シークレットを保存する代替手段です。Web Workers が安全なブラウザー ストレージを提供するには、シークレットを必要とするコードはすべて Web Workers 内に存在し、シークレットがメイン ウィンドウ コンテキストに送信されないようにする必要があります。

Web Worker のメモリ内にシークレットを保存すると、HttpOnly Cookie と同じセキュリティ保証が提供されます。つまり、シークレットの機密性が保護されます。ただし、XSS 攻撃を使用して Web Worker にメッセージを送信し、シークレットを必要とする操作を実行することは可能です。Web Worker は、操作の結果をメイン実行スレッドに返します。

HttpOnly Cookie と比較した Web Worker 実装の利点は、Web Worker では分離された JavaScript コードがシークレットにアクセスできることです。一方、HttpOnly Cookie はどの JavaScript からもアクセスできません。フロントエンドの JavaScript コードがシークレットにアクセスする必要がある場合、Web Worker 実装はシークレットの機密性を保持する唯一のブラウザー ストレージ オプションです。

## セッションIDのライフサイクル

セッション ID の生成と検証: 許容型と厳密型のセッション管理¶
セッション固定の脆弱性に関連する Web アプリケーションのセッション管理メカニズムには、許容型と厳密型の 2 種類があります。許容型メカニズムでは、Web アプリケーションは最初にユーザーが設定したセッション ID 値を有効として受け入れ、新しいセッションを作成できます。一方、厳密型メカニズムでは、Web アプリケーションが以前に生成したセッション ID 値のみを受け入れるように強制します。

セッション トークンは、可能な場合は Web サーバーによって処理されるか、暗号化された安全な乱数ジェネレータによって生成される必要があります。

現在使用されている最も一般的なメカニズムは strict （より安全）ですが、PHP のデフォルトは permissive です。開発者は、特定の状況下で Web アプリケーションが permissive メカニズムを使用しないようにする必要があります。Web アプリケーションは、生成したことのないセッション ID を決して受け入れてはなりません。セッション ID を受け取った場合は、新しい有効なセッション ID を生成してユーザーに提供する必要があります。さらに、このシナリオは疑わしいアクティビティとして検出され、アラートが生成される必要があります。

セッションIDを他のユーザー入力と同様に管理する¶
セッション ID は、Web アプリケーションによって処理される他のユーザー入力と同様に信頼できないものとみなされ、徹底的に検証および確認される必要があります。使用されるセッション管理メカニズムに応じて、セッション ID は GET または POST パラメータ、URL、または HTTP ヘッダー (例: クッキー) で受信されます。Web アプリケーションが無効なセッション ID 値を処理前に検証およびフィルター処理しない場合、セッション ID がリレーショナル データベースに保存されている場合は SQL インジェクション、セッション ID が Web アプリケーションによって保存され、後で反映される場合は永続的な XSS など、他の Web の脆弱性を悪用される可能性があります。

権限レベルの変更後にセッションIDを更新する¶
関連するユーザー セッション内で権限レベルが変更された後は、Web アプリケーションによってセッション ID を更新または再生成する必要があります。セッション ID の再生成が必須となる最も一般的なシナリオは、認証プロセス中であり、ユーザーの権限レベルが認証されていない (または匿名) 状態から認証済みの状態に変更されますが、場合によってはまだ承認されていない状態になることがあります。考慮すべき一般的なシナリオには、パスワードの変更、権限の変更、または Web アプリケーション内での通常のユーザー ロールから管理者ロールへの切り替えなどがあります。Web アプリケーションのすべての機密ページについては、以前のセッション ID を無視し、保護されたリソースに対して受信したすべての新しい要求に現在のセッション ID のみを割り当て、古いセッション ID または以前のセッション ID を破棄する必要があります。

最も一般的な Web 開発フレームワークは、request.getSession(true)& HttpSession.invalidate()(J2EE)、Session.Abandon()& Response.Cookies.Add(new...)(ASP .NET)、session_start()& session_regenerate_id(true)(PHP) など、セッション ID を更新するためのセッション関数とメソッドを提供します。

セッション ID の再生成は、セッション固定攻撃を防ぐために必須です。セッション固定攻撃では、攻撃者は、他のほとんどのセッションベースの攻撃のように被害者のセッション ID を収集するのではなく、HTTP または HTTPS の使用とは無関係に、被害者のユーザーの Web ブラウザーにセッション ID を設定します。この保護により、HTTP レスポンス分割や XSS など、セッション固定攻撃を開始するためにも使用される可能性がある他の Web ベースの脆弱性の影響が軽減されます (こちらとこちらを参照)。

補足的な推奨事項としては、認証前と認証後に異なるセッション ID またはトークン名 (またはセッション ID のセット) を使用することです。これにより、Web アプリケーションは、両方の状態間でユーザー セッションが公開されたりバインドされたりするリスクなしに、匿名ユーザーと認証済みユーザーを追跡できます。

複数のCookieを使用する場合の考慮事項¶
Web アプリケーションがセッション ID 交換メカニズムとして Cookie を使用し、特定のセッションに複数の Cookie が設定されている場合、Web アプリケーションはユーザー セッションへのアクセスを許可する前に、すべての Cookie を検証し (それらの間の関係を強制し) る必要があります。

ウェブ アプリケーションが HTTP 経由で認証前のユーザー Cookie を設定して、認証されていない (または匿名の) ユーザーを追跡することは非常に一般的です。ユーザーがウェブ アプリケーションで認証されると、新しい認証後の安全な Cookie が HTTPS 経由で設定され、両方の Cookie とユーザー セッション間のバインディングが確立されます。ウェブ アプリケーションが認証されたセッションの両方の Cookie を検証しない場合、攻撃者は認証前の保護されていない Cookie を利用して、認証されたユーザー セッションにアクセスできます (こことここを参照)。

Web アプリケーションでは、同じ Web アプリケーション内の異なるパスまたはドメイン スコープに同じ Cookie 名を使用しないようにする必要があります。これは、ソリューションの複雑さが増し、スコープの問題が発生する可能性があるためです。

## セッションの有効期限
攻撃者がアクティブなセッションに対して攻撃を仕掛け、それらを乗っ取る期間を最小限に抑えるためには、すべてのセッションに有効期限のタイムアウトを設定し、セッションがアクティブなままになる時間の長さを確立することが必須です。Web アプリケーションによるセッションの有効期限が不十分だと、他のセッションベースの攻撃にさらされる可能性が高くなります。攻撃者が有効なセッション ID を再利用して関連するセッションを乗っ取るには、そのセッションがまだアクティブである必要があります。

セッション間隔が短いほど、攻撃者が有効なセッション ID を使用できる時間が短くなります。セッション有効期限のタイムアウト値は、Web アプリケーションの目的と性質に応じて設定し、セキュリティと使いやすさのバランスをとる必要があります。そうすることで、ユーザーは頻繁にセッションが期限切れになることなく、Web アプリケーション内での操作を快適に完了できます。

アイドル タイムアウト値と絶対タイムアウト値はどちらも、Web アプリケーションとそのデータの重要度に大きく依存します。一般的なアイドル タイムアウト範囲は、高価値アプリケーションの場合は 2 ～ 5 分、低リスク アプリケーションの場合は 15 ～ 30 分です。絶対タイムアウトは、ユーザーが通常アプリケーションを使用する時間によって異なります。アプリケーションがオフィス ワーカーによって 1 日中使用されることを想定している場合、適切な絶対タイムアウト範囲は 4 ～ 8 時間になります。

セッションの有効期限が切れると、Web アプリケーションはクライアントとサーバーの両方でセッションを無効にするためのアクティブなアクションを実行する必要があります。セキュリティの観点からは、サーバー側が最も重要かつ必須です。

ほとんどのセッション交換メカニズムでは、セッション ID を無効にするクライアント側のアクションは、トークン値をクリアすることに基づいています。たとえば、Cookie を無効にするには、セッション ID に空 (または無効な) 値を指定し、Expires(またはMax-Age) 属性を過去の日付に設定することをお勧めします (永続的な Cookie が使用されている場合)。Set-Cookie: id=; Expires=Friday, 17-May-03 18:45:00 GMT

サーバー側でセッションを閉じて無効にするには、セッションの有効期限が切れたとき、またはユーザーが積極的にログアウトしたときに、HttpSession.invalidate()(J2EE)、Session.Abandon()(ASP .NET)、session_destroy()/unset()(PHP) などのセッション管理メカニズムが提供する関数とメソッドを使用して、Web アプリケーションがアクティブなアクションを実行する必要があります。

## 自動セッション有効期限

## アイドルタイムアウト

すべてのセッションは、アイドル タイムアウトまたは非アクティブ タイムアウトを実装する必要があります。このタイムアウトは、セッションにアクティビティがない場合にセッションがアクティブなままになる時間を定義します。指定されたセッション ID に対して Web アプリケーションが受信した最後の HTTP 要求以降、定義されたアイドル期間が経過すると、セッションが閉じられ、無効になります。

アイドル タイムアウトにより、攻撃者が別のユーザーの有効なセッション ID を推測して使用する可能性が制限されます。ただし、攻撃者が特定のセッションをハイジャックできる場合、アイドル タイムアウトでは攻撃者のアクションが制限されず、攻撃者はセッションで定期的にアクティビティを生成して、セッションを長時間アクティブにしておくことができます。

セッション タイムアウトの管理と有効期限は、サーバー側で強制する必要があります。クライアントを使用してセッション タイムアウトを強制する場合 (たとえば、セッション トークンまたは他のクライアント パラメータを使用して時間参照 (ログイン時からの分数など) を追跡する)、攻撃者はこれらを操作してセッション期間を延長できます。

## 絶対タイムアウト
すべてのセッションは、セッション アクティビティに関係なく、絶対タイムアウトを実装する必要があります。このタイムアウトは、セッションがアクティブになることができる最大時間を定義します。セッションは、Web アプリケーションによって最初に作成されてから定義された絶対期間で閉じられ、無効になります。セッションが無効になった後、ユーザーは Web アプリケーションで再度認証 (再認証) され、新しいセッションを確立する必要があります。

絶対セッションは、攻撃者がハイジャックしたセッションを使用して被害者のユーザーになりすますことができる時間を制限します。

## 更新タイムアウト
あるいは、Web アプリケーションは追加の更新タイムアウトを実装できます。このタイムアウトの後、ユーザー セッションの途中で、セッション アクティビティ (したがってアイドル タイムアウト) とは関係なく、セッション ID が自動的に更新されます。

セッションが最初に作成されてから一定の時間が経過すると、Web アプリケーションはユーザー セッションの新しい ID を再生成し、クライアントでその ID を設定または更新しようとします。以前のセッション ID 値は、クライアントが新しい ID を認識して使用を開始するまでの安全間隔を考慮して、しばらくの間は有効のままになります。その時点で、クライアントが現在のセッション内で新しい ID に切り替えると、アプリケーションは以前の ID を無効にします。

このシナリオでは、攻撃者が取得した可能性のある特定のセッション ID 値が、被害者のユーザー セッションがまだアクティブな場合でも、ユーザー セッションをハイジャックするために再利用される時間を最小限に抑えます。ユーザー セッションは、正当なクライアント上では存続し、開いたままですが、関連付けられたセッション ID 値は、更新タイムアウトが期限切れになるたびに、セッション期間中に定期的に透過的に更新されます。したがって、更新タイムアウトは、アイドル タイムアウトと絶対タイムアウトを補完します。特に、絶対タイムアウト値が時間の経過とともに大幅に延長される場合 (たとえば、ユーザー セッションを長時間開いたままにすることがアプリケーションの要件である場合) は、これが当てはまります。

実装によっては、更新タイムアウトが経過した直後に、以前のセッション ID がまだ有効な攻撃者が被害者のユーザーより先にリクエストを送信し、更新されたセッション ID の値を最初に取得するという競合状態が発生する可能性があります。少なくともこのシナリオでは、被害者のユーザーは、関連付けられたセッション ID が無効になったためにセッションが突然終了するため、攻撃に気付く可能性があります。

## 手動セッション有効期限
Web アプリケーションは、セキュリティを意識したユーザーが Web アプリケーションの使用を終了したら、セッションを積極的に閉じることができるメカニズムを提供する必要があります。

## ログアウトボタン
Web アプリケーションは、ユーザーがいつでも手動でセッションを閉じることができるように、Web アプリケーションのヘッダーまたはメニューで使用可能で、すべての Web アプリケーションのリソースとページからアクセスできる、目に見えて簡単にアクセスできるログアウト (ログオフ、終了、またはセッションを閉じる) ボタンを提供する必要があります。Session_Expiration セクションで説明されているように、 Web アプリケーションは少なくともサーバー側でセッションを無効にする必要があります。

注: 残念ながら、すべての Web アプリケーションでユーザーが現在のセッションを閉じることができるわけではありません。そのため、クライアント側の拡張機能により、良心的なユーザーはセッションを慎重に閉じることでセッションを保護できます。

## Web コンテンツのキャッシュ
セッションが終了した後でも、Web ブラウザのキャッシュを通じて、セッション内で交換されたプライベートまたは機密データにアクセスできる可能性があります。したがって、Web アプリケーションは、HTTP および HTTPS を介して交換されるすべての Web トラフィックに対して、制限的なキャッシュ ディレクティブを使用する必要があります。たとえば、Cache-ControlすべてPragmaの Web ページまたは少なくとも機密性の高い Web ページでは、HTTP ヘッダーや同等の META タグを使用する必要があります。

Web アプリケーションによって定義されたキャッシュ ポリシーとは関係なく、Web アプリケーション コンテンツのキャッシュが許可されている場合、セッション ID はキャッシュされてはならないため、Cache-Control: no-cache="Set-Cookie, Set-Cookie2"Web クライアントがセッション ID 以外のすべてをキャッシュできるようにするには、ディレクティブを使用することを強くお勧めします (こちらを参照)。

## セッション管理のための追加のクライアント側防御
Web アプリケーションは、クライアント側で追加の対策を講じることで、前述のセッション管理防御を補完できます。クライアント側の保護は、通常、JavaScript のチェックと検証の形式で行われますが、完全な防御策ではなく、熟練した攻撃者によって簡単に破られる可能性がありますが、侵入者が回避しなければならない別の防御層を導入する可能性があります。

## 初回ログインタイムアウト
Web アプリケーションは、ログイン ページで JavaScript コードを使用して、ページが読み込まれてセッション ID が付与されてからの時間を評価および測定できます。特定の時間が経過した後にログインを試行すると、クライアント コードは、ログインの最大時間が経過したことをユーザーに通知し、ログイン ページを再読み込みして新しいセッション ID を取得できます。

この追加の保護メカニズムは、セッション ID の事前認証の更新を強制し、セッション固定攻撃などで、以前に使用された (または手動で設定された) セッション ID が同じコンピューターを使用する次の被害者によって再利用されるシナリオを回避します。

## Web ブラウザ ウィンドウを閉じるイベントでセッションを強制ログアウトする
Web アプリケーションは、JavaScript コードを使用して、Web ブラウザーのタブまたはウィンドウを閉じる (または戻る) イベントをすべてキャプチャし、Web ブラウザーを閉じる前に現在のセッションを閉じるための適切なアクションを実行して、ユーザーがログアウト ボタンを使用して手動でセッションを閉じたことをエミュレートできます。

## Webブラウザのクロスタブセッションを無効にする
ユーザーがログインしてセッションが確立されると、Web アプリケーションは JavaScript コードを使用して、同じ Web アプリケーションに対して新しい Web ブラウザー タブまたはウィンドウが開かれた場合にユーザーに再認証を強制することができます。Web アプリケーションは、複数の Web ブラウザー タブまたはウィンドウが同じセッションを共有することを許可しません。そのため、アプリケーションは Web ブラウザーがそれらのタブまたはウィンドウ間で同時に同じセッション ID を共有しないように強制しようとします。

注意: セッション ID が Cookie を介して交換される場合、Cookie はすべての Web ブラウザーのタブ/ウィンドウで共有されるため、このメカニズムは実装できません。

## 自動クライアントログアウト

JavaScript コードは、Web アプリケーションのすべてのページ (または重要なページ) で使用して、アイドル タイムアウトの期限が切れた後に、ユーザーをログアウト ページ (前述のログアウト ボタンで使用されるのと同じリソース) にリダイレクトするなどして、クライアント セッションを自動的にログアウトすることができます。

サーバー側のアイドル タイムアウト機能をクライアント側のコードで強化する利点は、ユーザーが非アクティブ状態によってセッションが終了したことを確認できること、またはカウント ダウン タイマーと警告メッセージによってセッションの有効期限が近づいていることを事前に通知できることです。このユーザー フレンドリなアプローチにより、サーバー側で自動的に期限切れになったセッションが原因で大量の入力データを必要とする Web ページで作業が失われるのを防ぐことができます。

セッション攻撃検出¶
セッションID推測とブルートフォース検出¶
攻撃者が有効なセッション ID を推測またはブルート フォース攻撃しようとする場合、単一の (または IP アドレス セット) から異なるセッション ID を使用して、ターゲット Web アプリケーションに対して複数の連続したリクエストを発行する必要があります。さらに、攻撃者がセッション ID の予測可能性を分析しようとする場合 (統計分析などを使用)、新しい有効なセッション ID を収集するために、単一の (または IP アドレス セット) からターゲット Web アプリケーションに対して複数の連続したリクエストを発行する必要があります。

Web アプリケーションは、異なるセッション ID を収集 (または使用) する試行回数に基づいて両方のシナリオを検出し、問題のある IP アドレスを警告および/またはブロックできる必要があります。

## セッションIDの異常の検出
Web アプリケーションは、セッション ID の操作など、セッション ID に関連する異常の検出に重点を置く必要があります。OWASP AppSensor プロジェクトは、検出ポイントと応答アクションの形式で、異常と予期しない動作の検出に重点を置いた、Web アプリケーション内に組み込みの侵入検出機能を実装するためのフレームワークと方法論を提供します。外部の保護レイヤーを使用する代わりに、ビジネス ロジックの詳細と高度なインテリジェンスは、Web アプリケーションの内部からのみ利用できる場合があります。その場合、既存の Cookie が変更または削除された場合、新しい Cookie が追加された場合、別のユーザーのセッション ID が再利用された場合、またはセッションの途中でユーザーの場所またはユーザー エージェントが変更された場合など、複数のセッション関連の検出ポイントを確立できます。

セッションIDを他のユーザープロパティにバインドする¶
ユーザーの不正行為やセッション ハイジャックを検出 (および、場合によっては保護) することを目標として、セッション ID を他のユーザーまたはクライアント プロパティ (クライアント IP アドレス、User-Agent、クライアント ベースのデジタル証明書など) にバインドすることを強くお勧めします。Web アプリケーションが、確立されたセッションの途中でこれらのさまざまなプロパティ間で変更または異常を検出した場合、これはセッション操作やハイジャックの試みを示す非常に優れた指標であり、この単純な事実を使用して、疑わしいセッションを警告したり終了したりできます。

これらのプロパティは、Web アプリケーションがセッション攻撃を確実に防御するために使用することはできませんが、Web アプリケーションの検出 (および保護) 機能を大幅に向上させます。ただし、熟練した攻撃者は、同じネットワークを共有する (Wi-Fi ホットスポットなどの NAT 環境では非常に一般的) か、同じ送信 Web プロキシを使用する (企業環境では非常に一般的) ことで、被害者のユーザーに割り当てられた同じ IP アドレスを再利用するか、または User-Agent を被害者のユーザーとまったく同じに見えるように手動で変更することで、これらの制御を回避できます。

セッションのライフサイクルのログ記録: セッション ID の作成、使用、破棄の監視¶
Web アプリケーションは、セッションのライフサイクル全体に関する情報を含めることで、ログ機能を強化する必要があります。特に、セッション ID の作成、更新、破棄などのセッション関連イベント、ログインおよびログアウト操作での使用の詳細、セッション内の権限レベルの変更、タイムアウトの有効期限、無効なセッション アクティビティ (検出された場合)、セッション中の重要なビジネス操作を記録することをお勧めします。

ログの詳細には、タイムスタンプ、ソース IP アドレス、要求された (およびセッション操作に関係する) Web ターゲット リソース、HTTP ヘッダー (User-Agent および Referer を含む)、GET および POST パラメーター、エラー コードとメッセージ、ユーザー名 (またはユーザー ID)、およびセッション ID (Cookie、URL、GET、POST など) が含まれる場合があります。

セッション ID などの機密データは、セッション ログをセッション ID のローカルまたはリモート開示や不正アクセスから保護するために、ログに含めないでください。ただし、ログ エントリを特定のセッションに関連付けるために、何らかのセッション固有の情報をログに記録する必要があります。セッション ID を公開せずにセッション固有のログ関連付けを可能にするために、セッション ID 自体ではなく、セッション ID のソルト ハッシュをログに記録することをお勧めします。

特に、Web アプリケーションは、現在アクティブなセッションをすべて管理できる管理インターフェイスを徹底的に保護する必要があります。サポート担当者は、ユーザーになりすまして Web アプリケーションをユーザーと同じように操作し、セッション関連の問題や一般的な問題を解決するために、これらのインターフェイスを使用することがよくあります。

セッション ログは、Web アプリケーション侵入検出の主要なデータ ソースの 1 つとなり、侵入防止システムによって、(1 つまたは複数の) 攻撃が検出されたときに自動的にセッションを終了したり、ユーザー アカウントを無効にしたりするためにも使用されます。アクティブな保護が実装されている場合は、これらの防御アクションもログに記録する必要があります。

## 同時セッションログオン
同じユーザーによる複数の同時ログオンを、同じクライアント IP アドレスから許可するか、異なるクライアント IP アドレスから許可するかは、Web アプリケーションの設計上の決定事項です。Web アプリケーションで同時セッション ログオンを許可しない場合は、新しい認証イベントのたびに、以前に使用可能だったセッションを暗黙的に終了するか、アクティブのままにしておく必要があるセッションについてユーザーに問い合わせる (古いセッション、新しいセッション、または両方のセッションを通じて) など、効果的なアクションを実行する必要があります。

Web アプリケーションには、アクティブなセッションの詳細をいつでも確認したり、同時ログオンを監視してユーザーに警告したり、セッションを手動でリモートで終了するユーザー機能を提供したり、IP アドレス、ユーザー エージェント、ログイン日時、アイドル時間などの複数のクライアントの詳細を記録してアカウント アクティビティ履歴 (ログブック) を追跡したりできるユーザー機能を追加することをお勧めします。

## セッション管理WAF保護
Web アプリケーションのソース コードが利用できない、または変更できない場合や、上記で詳述した複数のセキュリティ推奨事項とベスト プラクティスを実装するために必要な変更により、Web アプリケーション アーキテクチャの完全な再設計が必要になり、短期間で簡単に実装できない場合があります。

このようなシナリオでは、Web アプリケーションの防御を補完し、Web アプリケーションを可能な限り安全に保つという目標を掲げて、すでに説明したセッション管理の脅威を軽減できる Web アプリケーション ファイアウォール (WAF) などの外部保護を使用することをお勧めします。

Web アプリケーション ファイアウォールは、セッション ベースの攻撃に対する検出機能と保護機能を提供します。一方で、WAF では、新しい Cookie を設定するすべての Web アプリケーション応答のヘッダーに基本的な書き換えルールを適用して、 や フラグSecureなどの Cookie のセキュリティ属性の使用を強制することは簡単です。HttpOnlySet-Cookie

一方、より高度な機能を実装して、WAF がセッションと対応するセッション ID を追跡し、セッション固定 (権限の変更が検出されたときにクライアント側でセッション ID を更新することによって)、スティッキー セッションの強制 (セッション ID と IP アドレスやユーザー エージェントなどの他のクライアント プロパティとの関係を検証することによって)、またはセッション有効期限の管理 (クライアントと Web アプリケーションの両方にセッションの終了を強制することによって) に対するあらゆる種類の保護を適用できるようにすることもできます。

オープンソースの ModSecurity WAF と OWASP Core Rule Set は、セキュリティ Cookie 属性を検出して適用する機能、セッション固定攻撃に対する対策、スティッキー セッションを強制するセッション追跡機能を提供します。
