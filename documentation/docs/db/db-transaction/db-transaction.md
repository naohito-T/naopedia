# DB Transaction

## Overview

トランザクションについてのセクション  
更新は単独のクエリで行われることは少なく、複数のクエリで連続的に行われることがほぼ。  
更新の元データとしてSELECTを利用する場合は、それを含めて複数のクエリを一貫性のある形でひとまとまりにして扱う必要がある。  
トランザクションとは、このような複数のクエリをひとまとまりにしたもの。

## トランザクションの特性(ACID特性)

4つの特性により定義されACID特性と呼ばれる

1. Atomicity（原子性）
2. Consistency（一貫性）
3. Isolation（分離性もしくは隔離性、独立性）
   1. ロック制限
      1. 表全体
      2. ブロック単位
      3. 行単位
   2. シリアライザブル（DBMSの仕様）
      1. ダーティリード（ANSIが定義）
      2. リピータブルリード（ANSIが定義）
      3. ファントムリード（ANSIが定義）
4. Durability（持続性）

## Atomicity（原子性）

「原子性」とは、データの変更（INSERT/UPDATE/DELETE）を伴う一連のデータ操作が「全部成功」するか「全部失敗」するかを保証する仕組み  
トランザクションではすべての処理の後に`COMMIT`を発行して処理を確定する。  
その場合にそれぞれのデータ操作は永続的となり、結果が失われないようになる。  
また、このようにシステムが正常動作していた上でのエラーではなくクライアントからサーバへの通信が途絶えてしまったり、サーバがダウンしてしまった場合でも、COMMITされたもの以外はROLLBACKする仕組みになっている

## Consistency（一貫性）

データベースには、データベースオブジェクト（テーブルをはじめとするデータベース内に定義できるオブジェクト）に対して、各種整合性制約を付加できる。  
これは、一連のデータ操作の前後でそれらの状態を保つことを保証する、すなわち「一貫性」を保つための仕組み

たとえばシステムに利用ユーザを登録する場合、そのユーザを一意に識別するために、連番をユーザに振って（ユーザ番号）、それに対してユニーク制約（一意制約）を設定した場合、重複するようなユーザ番号を格納することはできない。  
これは複数のユーザが同時にユーザ番号を取得しようとした場合も同じ。

## Isolation（分離性もしくは隔離性、独立性）

トランザクション分離レベルと言われているもの  
「分離性（隔離性、独立性）」とは、一連のデータ操作が、複数のユーザから同時に行われる際に、「それぞれの処理が矛盾なく行えることを保証する」こと。

ロックの単位には「表全体」「ブロック単位」「行単位」などがありますが、MySQLでトランザクション処理を行う場合は、主に行単位のロック機能を利用する。  
具体的には、処理で`SELECT〜FOR UPDATE`を実行することにより、SELECTした行にロックがかかる。　　
すると、後続の処理は、そのロックが解放される（COMMITまたはROLL BACK、今回COMMIT）まで待たされ、正しく処理を継続することができるという仕組み

この仕組みに関してはDBのテーブル型が関わってくる  
`InnoDB`型のテーブルは「MVCC」という仕組みで動作しているため、今回の例でユーザBが単純に値を参照する、といった場合には、`SELECTにFOR UPDATE`は不要であり、その場合読み取りはブロックされない。  
そのため、更新するユーザが少数で、参照するユーザが多い場合には、ユーザの同時実行・並列実行性が高くなる

[![Image from Gyazo](https://i.gyazo.com/2abc208ad9b33baeb1720c5f8a5c4a0b.png)](https://gyazo.com/2abc208ad9b33baeb1720c5f8a5c4a0b)

### シリアライザブル（Serializable:直列化可能）

これを分離性のレベルとしてDBMS側で実装・提供しているものが「シリアライザブル（Serializable:直列化可能）」という仕様。  
しかしながら、「シリアライザブル」の分離度では、常に同時に動作しているトランザクションは1つのイメージとなってしまい、パフォーマンス的に実用に耐えられない。  
そのため、シリアライザブルから分離の厳格性を緩めて、シリアライザブル以外に、自分以外のトランザクションの影響を受けることを許容する3つのレベルが「ANSI」という規格団体によって定義されている。  
それらの呼称を**トランザクション分離レベル**という

[![Image from Gyazo](https://i.gyazo.com/1c0912f8ae7cea919d50169778e752a5.png)](https://gyazo.com/1c0912f8ae7cea919d50169778e752a5)

### トランザクション分離レベル（Transaction Isolation Level）

※どの分離レベルをサポートするかはDBMSによって変わる場合もある。以下は`MySQL`の場合

データベース管理システム（DBMS）の機能であり、DBレイヤーで制御されます。  
ORM（Object-Relational Mapping）ツールやフレームワーク（たとえば、ActiveRecordなど）は、このDBレイヤーの機能を利用して分離レベルを指定し、管理しています。  
トランザクション分離レベルは**データベースのトランザクションが他の同時実行トランザクションの影響をどの程度受けるか**を定義する設定  
データベース管理システム（DBMS）では、トランザクションの一貫性を保ちながら同時実行性を管理するために、異なる分離レベルが提供されている。
SQL標準では、4つの主要なトランザクション分離レベルが定義されています。それぞれの分離レベルは、データの一貫性とパフォーマンスのバランスを取るために異なるトレードオフを提供します。
トランザクション分離レベルは、データベースのトランザクションが他の同時実行トランザクションの影響をどの程度受けるかを制御します。分離レベルを適切に選択することで、データの一貫性とパフォーマンスのバランスを最適化することが可能。

- **READ COMMITTED**: ダーティリードを防ぎますが、ファジーリードは防ぎません。
- **REPEATABLE READ**: ファジーリードを防ぎますが、ファントムリードを防ぎません。
- **SERIALIZABLE**: すべてのリードの問題（ダーティリード、ファジーリード、ファントムリード）を防ぎますが、もっとも制約が厳しく、パフォーマンスに影響を与える可能性があります。

1. **READ UNCOMMITTED（非コミット読み取り）**
   1. **説明**: 他のトランザクションがコミットしていない変更（ダーティリード）を読み取ることができます。
   2. **利点**: 高い同時実行性とパフォーマンス。
   3. **欠点**: データの一貫性が保証されないため、もっとも低い分離レベル。
2. **READ COMMITTED（コミット済み読み取り）**
   1. **説明**: 他のトランザクションがコミットした変更のみを読み取ることができます。ダーティリードは発生しません。
   2. **利点**: データの一貫性がある程度保証される。
   3. **欠点**: ファジーリード（同じクエリ内で異なる結果が返されること）が発生する可能性がある。
3. **REPEATABLE READ（再読み込み可能読み取り）**
   1. **説明**: トランザクション内で読み取ったデータが、トランザクション終了まで変更されないことを保証します。ダーティリードやファジーリードは発生しませんが、ファントムリード（範囲クエリが新しい行を返すこと）は発生する可能性があります。
   2. **利点**: 高いデータ一貫性。
   3. **欠点**: パフォーマンスが低下する可能性。
4. **SERIALIZABLE（直列化可能）**
   1. **説明**: もっとも高い分離レベルで、すべてのトランザクションがシリアルに実行されたかのように扱われます。ファントムリードも防止されます。
   2. **利点**: 完全なデータ一貫性。
   3. **欠点**: 同時実行性がもっとも低く、パフォーマンスに大きな影響を与える可能性。

各分離レベルは、以下の現象を制御するために使用される。

- **ダーティリード（Dirty Read）**: 他のトランザクションがコミットしていない変更を読み取る。
- **ファジーリード（Non-repeatable Read）**: 同じクエリを複数回実行した際に、異なる結果が返される。
- **ファントムリード（Phantom Read）**: トランザクション内で範囲クエリを実行した際に、新しい行が挿入されることで異なる結果が返される。

### 使用例

たとえば、Railsでトランザクション分離レベルを指定する場合は、以下のように設定する。  
この設定により、トランザクションは`SERIALIZABLE`分離レベルで実行され、完全なデータ一貫性が保証されます。

```ruby
ActiveRecord::Base.transaction(isolation: :serializable) do
  # トランザクション内の処理
end
```

PostgreSQLでは、以下のようにトランザクション分離レベルを設定します：

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- トランザクション内の処理
COMMIT;
```

MySQLでは、以下のようにトランザクション分離レベルを設定します：

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
-- トランザクション内の処理
COMMIT;
```

[ダーティリード、リピータブルリード、ファントムリードをちゃんと理解してからトランザクション分離レベルを理解しよう](https://qiita.com/momotaro98/items/ad859ec2934ee98540fb)  

### ダーティリード(Dirty Read)

あるトランザクションがコミットされる前に、別のトランザクションからデータを読み出せてしまう現象。  
たとえばユーザAが値を変更し、まだコミットしていない場合でもユーザBが変更後の値を読み出してしまうことを指す。  
ユーザAが部屋の残数「10」であるレコードを「9」に変更した場合、コミット前でもユーザBがSELECTした結果が「9」になる確定前の「汚れた（Dirty）」データを読み出し（Read）てしまうことから付いた名前

別のトランザクションでコミットされていないデータが読み取れる現象

1. トランザクションAでレコードを①から②にUPDATE（未コミット）
2. トランザクションBでレコードをSELECTする
3. トランザクションAをロールバックする
4. トランザクションBで取得したデータは②となっている。

>一番低いレベルでないと発生しない。これを許容するシステムをまだ見たことがない・・

### ファジーリード(非再現リード,ノンリピータブルリード)：Fuzzy Read

あるトランザクションが以前読み込んだデータを再度読み込んだとき、2回目以降の結果が1回目と異なる現象。  
たとえば最初にユーザAが部屋の残数「10」を読み出し、その後ユーザBが値を「9」に変更しコミットも行ったとする。  
続いて、ユーザAがSELECTを再度実行すると、最初にSELECTできた「10」ではなく、変更後の「9」が読み出されてしまう。  
ユーザAが最初に読み出し（Read）た値「10」が、2回目以降のSELECTで保証されず曖昧（Fuzzy）になることから付いた名前。  
DBMSのマニュアルでは「繰り返し不可能な読み出し」(Non Repeatable Read) と紹介されることもある

> トランザクション分離レベル知る前はそういうもんじゃんとか思っていたんだけど、2つのトランザクションが隔離されてないので使ってる側で気にしないといけない。
> その時点で隔離性から離れてるんだよね。

### ファジーリードの説明

1. **トランザクションA**がレコードを`SELECT`する。たとえば、レコードの値が`①`であるとします。
2. **トランザクションB**が同じレコードを`①`から`②`に`UPDATE`し、その後`COMMIT`します。
3. **トランザクションA**が再度同じレコードを`SELECT`すると、その値は`②`になっています。

### 何が問題か？

ファジーリードは、トランザクションの一貫性と隔離性を損なうため、問題が発生します。  
これを防ぐためには、適切なトランザクション分離レベルを設定することが重要。  
とくに、`REPEATABLE READ`以上の分離レベルを設定することで、ファジーリードを防止し、トランザクションが予期せぬ結果を取得するのを避けることができる。

#### 1. 一貫性の欠如

ファジーリードが発生すると、トランザクションAは同じクエリを2回実行したにもかかわらず、異なる結果を取得します。これは、データの一貫性を損なう原因となります。

- **例**: 銀行の口座残高を確認するシステムでは、最初に取得した残高が`$100`で、その後に確認した際に`$50`に変わっていた場合、システムは正しく機能しない可能性があります。

#### 2. トランザクションの隔離性の欠如

トランザクションの隔離性（Isolation）は、トランザクションが他の同時実行トランザクションの影響を受けないことを保証するための特性です。ファジーリードが発生する場合、この隔離性が維持されていません。

- **例**: トランザクションAは、データがトランザクションBによって変更される影響を受けています。これにより、トランザクションAが意図した通りにデータを扱うことができなくなります。

### ファントムリード（Phantom Read）

あるトランザクションを読み込んだとき、選択できるデータが現れたり消えたりする現象。  
最初にユーザAが範囲検索（たとえば部屋の残数が10以上のホテル）を行い、3行のレコードを読み出したとする。  
続いてユーザBがちょうどその範囲に収まるデータを1行INSERTし、コミットも行った。  
続いてユーザAが再度同じSELECT文を実行すると最初にSELECTできた3行ではなく、選択されるレコード数が4行になる。  
このように現れたり、消えたり（DELETEやUPDATEで消える）するデータが「幽霊（Phantom）」に似ていることから付いた名前

## Durability（持続性）

「持続性」は、一連のデータ操作（トランザクション操作）を完了（COMMIT）し、完了通知をユーザが受けた時点で、その操作が永続的となり結果が失われないことを示す。  
これはシステムの正常時だけにとどまらず、データベースサーバやOSの異常終了、つまりシステム障害に耐えるということ。  
MySQLを含め、多くのデータベースの実装では、トランザクション操作をハードディスクの上に「ログ」として記録し、システムに異常が発生したらそのログを用いて異常発生前の状態まで復旧することで持続性を実現している。  
