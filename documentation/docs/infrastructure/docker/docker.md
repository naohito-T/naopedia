# Docker
[Dockerfile(リフェレンス)](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)  
[入門Docker](https://y-ohgi.com/introduction-docker/)  
[軽量なDockerfileの作り方](https://qiita.com/watawuwu/items/d547d0cb1ab1db5e079c)  
[Dockerfile ベストプラティクス(かなりすごい)](https://zenn.dev/esaka/articles/cae40a30bbbfa495e6a9)  
[Dockerセキュリティ（これもLTに入れる）](https://qiita.com/ohhara_shiojiri/items/08909bfaed8073af57f0)

```sh
docker container prune -f;
docker image prune -f;
docker volume prune -f
```

## そもそもコンテナーとは

コンテナーとはアプリケーションの実行環境をパッケージ化し、それをデプロイ、実行するためのテクノロジーのこと。  
- アプリケーションコード
- ライブラリ
- プログラミング言語のランタイム

アプリケーションを実行するための依存関係をコンテナーイメージとしてパッケージ化する。  
また、パッケージ化されたコンテナーイメージは任意の場所で実行されるコンテナーランタイムによりコンテナーとして実行ができるようになる。

## コンテナーを利用することで得られるメリット

可搬性を得ることができる。  
※**どこでも同じ環境を再現**できる

## 昨今の開発

コンテナーの持つ可搬性によりさまざまなメリットが得られ、ユーザーがよりアプリケーション開発に集中できることから、サーバーレステクノロジーと同様にモダンアプリケーションにおける重要な選択肢の1つとなっています。  

Lambdaの方が抽象度高く、多くの作業をAWSにオフロードできる。  
Lambdaで要件を満たせない場合にAmazon ECSやAmazon EKSの採用を検討することになる。  
AWS Lambda関数の**タイムアウト設定は最大で15分**ですので、それ以上の実行時間が想定されるアプリケーションでは採用が難しくなる。  
そのような場合、アプリケーションの実行環境としてコンテナーが候補に挙がるため、Amazon ECSやAmazon EKSが選択肢に出てくる。

## サーバーレスとコンテナー使い分ける指標

アプリケーション開発に**より多くの時間や人を投資できる選択肢はどれか**という観点で整理する考え方。

## コンテナーをアプリケーション実行環境へする場合

Amazon EC2あるいはAWS Fargateが選択肢となる。  
Fargateを利用すると、Dockerなどのコンテナランタイムを含むAmazonEC2インスタンスの管理が不要となるため、コンテナワークロードの運用負荷が軽減されます

## Docker Linter

DockerfileのLinterとしてhadolintというものがデファクトスタンダードとして存在する。

## Docker node_modules テクニック
[参考URL](https://zenn.dev/yumemi_inc/articles/3d327557af3554)

- そもそもnode_modulesはgitと同じで除外する。
>まず、node_modulesはDockerイメージにホストからコピーしてはいけません。node_modulesはgitでも無視するはずなので、新しく環境構築する人のディレクトリにはそもそも入ってませんし、イメージをリビルドするときにホストのnode_modulesからイメージ内のnode_modulesが上書きされることも避ける必要があるからです。

- Volume Trickでnode_modulesがバインドマウントされるのを回避する
- VScodeでnode_modulesを参照できない問題を解決する。

## Docker が軽い方がいい理由
[参考URL](https://blog.mosuke.tech/entry/2020/07/09/container-image-size/)

## Docker imageの中身を見る(レイヤー)
[参考URL](https://zenn.dev/kirisaki/scraps/89bf93bfd9a0d6)

以下の要望があるときに見られる  
作成したイメージがどうなっているかを確認したいとき。  
レイヤーについて詳しく見られる。  

`docker save -o [name].tar [image id]`

## Docker mysql
[参考URL](https://qiita.com/nanakenashi/items/180941699dc7ba9d0922)

## dockerでvolumeをマウントした時のファイルowner問題
[参考URL](https://qiita.com/yohm/items/047b2e68d008ebb0f001)

ホスト側のファイルをコンテナー内で使いたい場合や、逆にコンテナーで作ったファイルにホストからアクセスしたい場合に有用なのだが、ファイルのアクセス権限について考慮すべき点がある。
ちなみにdocker for macで試したところ、上記の問題は起きない。
コンテナー内からはownerがrootとして表示されるが、mac上からは自ユーザーがownerとして表示されている。docker for macの中でうまく解決してくれているようだ。


## docker 仕組み
[参考URL](https://tech.plaid.co.jp/improve_docker_build_efficiency)  
Dockerは**ビルドのステップごとにファイルシステムの変更差分を積み重ねることでイメージを作成する。**  
先にGemfileをイメージに組み込んでbundle installを実行しておかなければソースコードを変更するたびに毎回bundle installをする必要がある。

```Dockerfile
# 先にGemfileを転送しbundle installする
COPY --chown=rails Gemfile Gemfile.lock package.json yarn.lock /app/

RUN bundle install
RUN yarn install
```
上記のような工夫をすることでGemfileの内容に変化がなかった場合は`bundle install`の工程までキャッシュを利用することが可能になり2回目以降のビルドが大きく高速化される。




---

## インストールするimageの中を確認する

そのイメージになにが含まれているのか確認する方法
`$ docker run -it alpine:3.11`
言語のalpineだと/bin/shなどで起動する必用がある。
`$ docker run -it alpine:3.11 /bin/sh`

## docker-composeではない起動方法

1. Dockerfileを用意する
2. build

## Docker コマンド一覧

run
imagesからコンテナーを起動する。

exec
起動中のコンテナーに入る


## リモートサーバー内のDockerにローカルから接続する

Dockerでもlocalhostでも起動した時に`0.0.0.0`などパブリックドメインで公開すればアクセスできる。
`0.0.0.0`

---

## Docker セキュリティ
[参考URL](https://www.creationline.com/lab/aquasecurity/42049)

コンテナセキュリティの課題は、ダウンロードしたコンテナイメージが期待通りであるか。
セキュリティと一貫性の観点から期待通りのイメージがダウンロードされることの保証が重要。
Dockerのイメージタグは便利だが常に一貫した特定のイメージを指すとは限らないため**SHA-256ハッシュを使ってイメージを識別すること**


TODO: これLT
アプリケーションがrootで実行されている
もしアプリケーションにOSコマンドインジェクションやディレクトリトラバーサルなどの脆弱性があり、それが悪用された場合アプリケーションがroot権限で実行されていると悲惨なことになります

## docker security  

[効率的に安全な Dockerfile を作るには](https://qiita.com/pottava/items/452bf80e334bc1fee69a)

---

## Docker パーミッション

LinuxではDockerを実行した場合、作成されたファイルの所有権が`root`になる（公式はrootで対応するなと言っている）
そのためDockerfileの`ADD/COPY`に`--chown`オプションができており、それ用のuserを作成するルールになっている。

Dockerfile ---chown
[参考URL](https://ken5scal.hatenablog.com/entry/2017/10/13/Dockerfile%E3%81%AEADD/COPY%E3%81%AB--chown%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%9F)

---

## Dockerイメージを軽くする

### Dockerfile ビルダーパターン

マルチステージビルドとも呼ばれていることがある。
ビルダーパターンなど（FROMが2度現れること）がある。
つまり、xxxパターンを調べて勉強しろ

### マルチステージビルド

マルチステージビルドは、Docker17.05以上で利用できる新機能
前のステージでビルドされた成果物をこの新しいステージへコピーする
最終的なイメージでは取り残され**最終的なイメージへは保存されない。**
※つまり、TypeScriptをコンパイルするステージ⇨最終的なJSを実行するステージに分けることができる。

```yml
COPY --from=0
```

[参考URL](https://qiita.com/carimatics/items/01663d32bf9983cfbcfe)

---
## Docker image削除

containerを削除してからではないとimageが削除できない。

### dockerignoreとは

docker buildでimageを作成する際に無視するファイル・ディレクトリを設定できる。
**※mountの場合は無視ができない。**

## Dockerのマウント種類
[参考URL](https://qiita.com/aki_55p/items/db706d0113cbdad6c51d)
mountディレクトリの恐ろしさ
たとえばDockerfile内でCopyをした場合、コピーされるがバインドマウントのためではないため編集しても反映されない。

**そのためdocker imageを作成するためだけを意識すること**
また、COPYでせっかく全部コピーしてもバインドマウントで同じディレクトリを指定した場合にバインドマウントの中身ですべて消される。これが注意！！



## alpine linux

alpine linuxは基本
**GCC などの C コンパイラが含まれていない(つまり開発ツール)**

[alpine linuxにyarnいれる](https://scrapbox.io/keroxp/alpine-linux%E3%81%AByarn%E3%82%92%E5%85%A5%E3%82%8C%E3%82%8B)
[python:alpineにCコンパイラをインストール](https://ja.stackoverflow.com/questions/42881/docker-pythonalpine%E3%81%A7cffi%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%AB%E5%A4%B1%E6%95%97%E3%81%99%E3%82%8B)

## Docker 参考文献

[お前らのDockerfileは重い。](https://speakerdeck.com/stormcat24/oqian-falsedockerimezihamadazhong-i?slide=13)
[世界一わかりみが深いコンテナー](https://tech-lab.sios.jp/archives/18811)
[Docker での Node 環境構築](https://www.creationline.com/lab/29422)
[Docker 環境構築best practice](https://www.forcia.com/blog/002273.html)

## Dockerコンテナー内のアプリケーションport

[Dockerポート仕組み](https://qiita.com/ksato9700/items/0b4c7de5d857dc731443)

Dockerコンテナー内のアプリケーションは、デフォルトでネットワークトラフィックを受け入れている。
→`http://127.0.0.1:3000`

このインターフェイスは外部トラフィックを受け入れないため、機能しないのも不思議ではありません。これを機能させるには、nuxtアプリのHOST環境変数を**0.0.0.0（すべてのIPアドレス）**に設定する必要がある。

コンテナーのサーバがlocalhostでlistenしていると、ホストマシンからアクセスした際にエラーが起きることを確認した。
これは、ホストマシンのlocalhostとコンテナーーのlocalhostが異なるため

ホストマシンとcontainerはnamespaceで区切られていて別のマシンと捉えて構わないため、containerのloopback interfaceにはホストマシンからはアクセスできない。

---

## イメージをビルドするタイミングとは？

1. Dockerfileを書き換えた時。
2. パッケージ管理を行うファイルを書き換えた時

---

## Dockerを軽くする方法

1. RUNはチェーンする（&&）とにかくつなげる。RUN毎にレイヤーが作成されてしまうため（実際これもどうなんだろうと言われている）
2. 産業廃棄物（docker build）時に生じた、アプリケーション実行には不要なツールやファイルを削除する
3. yumやapt-getのゴミ
4. ビルドに使用したソース
5. gitですら産業廃棄物
6. 成果物を残すことを意識する

- yarn installなどを早めたい

[nodeではやく](https://tkkm.tokyo/post-495/)

---

### docker-compose.yml => Dockerfileへ環境変数を渡す方法(1)

渡す側（docker-compose.yml）と
受け取る側（Dockerfile）**双方の設定が必要。**

1. docker-compose.ymlから渡す
args ... Dockerイメージを**ビルド（作成）する際**に引数を渡すために使用します。

この仕組みを使ってDockerfileへ環境変数を渡します。

```yml
services:
  api:
    build:
      context: ./api
      args:
				# キー: 値
        WORKDIR: $WORKDIR
        # この書き方でもOK
        - WORKDIR=$WORKDIR
```

2. Dockerfileで受け取る

ARG命令を使います。
指定する値は**docker-compose.ymlで渡したキーの名前**です。
受け取った後はDockerfile内で変数として扱うことができます

```Dockerfile
ARG WORKDIR

ENV HOME=/${WORKDIR}
```

## docker-compose.yml => コンテナーーへ環境変数を渡す方法

1. environment

environmentを使用する場合は<キー: 値>形式で環境変数を指定する。
**※これは扱う環境変数が少ない場合に使用する。**

```yml
services:
  api:
    environment:
      POSTGRES_PASSWORD: $POSTGRES_PASSWORD
      # この書き方でもOK
      - POSTGRES_PASSWORD=$POSTGRES_PASSWORD
```

2. env_file

env_fileを使用する場合は、環境変数を格納したファイルパスを指定します。
相対パス、絶対パスどちらでも良い。
これは扱う環境変数が多い場合に使用します。

```yml
services:
  api:
    env_file: ./.env
```

---

## ベースイメージを調べる方法

**重いイメージは本当にいいことがない。**
[参考URL](https://qiita.com/pottava/items/970d7b5cda565b995fe7)

>ベースイメージのRubyバージョンを調べる手順
>ちょっと豆知識。これからのプログラミング人生のために。

Rubyのバージョンは**開発時点の安定版**を使用するようにしましょう。

以下の手順でバージョンを調べます。

1. まず、Rails6に必要なRubyのバージョンを知る。
2. Railsガイド => Ruby 2.5.0以降が必要
3. 次にRuby 2.5.0以上の安定版を知る。
4. Ruby => 安定版は2.7.1
5. 最後にRuby 2.7.1のベースイメージを調べる。
6. Docker Hub => 2.7.1-alpineを採用

最近はオフィシャルでもAlpine版が存在している。

[Alpine参考URL](https://qiita.com/pottava/items/970d7b5cda565b995fe7)

---

## こうしたいんだぜという時の逆引きdocker

[参考URL](https://beyondjapan.com/blog/2016/08/docker-command-reverse-resolutions/)

## コマンド

近年Dockerコマンドはできるだけ次の書式に統一しようとしている

`$docker コマンド 操作 オプション`

## docker word

デタッチモード: コンテナーー内に入らずバックグラウンドで動作する状態のこと。
-dでやる

## dockerの基本運用概念

バインドマウントやボリュームマウントは**別の場所**に置き、コンテナーー自体は破棄されても問題ないような運用を心がけるべき方針

---

## 開発におけるdocker導入のメリット

[参考URL](https://qiita.com/minodisk/items/5ffd20588b995523756f)

>メリット

- 同一性
複数人で開発する際に、環境の差が生まれない。

- カプセル化
**アプリケーション込みの環境をコンテナーーというカプセルに隠蔽することができる。**
コンテナーーという単位に対するテストが可能に。
コンテナーーを捨てる・再生成するのが容易。

- ポータビリティ（一貫性とも）
開発に使ったコンテナーーをCIでテストできる。
**CIでテストしたコンテナーーをサーバーにデプロイできる。**
デプロイしたコンテナーーをスケールできる。

- ひとつのサーバにwebサーバを同居できる（Apache）
1台のDockerホストに2台のWebサーバを同居させることができるなど。
>ここまでの操作では、「http://Dockerホスト:8080/」「http://Dockerホスト:8081/」･･･のように、明示的なポート番号の指定での切り替えが必要です。実運用では、きっと、それぞれ、「http://www.example.co.jp/」「http://www.example.com/」など、アクセスするドメイン名で切り替えたいことでしょう。それは可能ですが、少し工夫が必要で、Dockerの力だけではできず、リバースプロキシとして構成します。


>メリットで防げる消耗

1. おれの環境では動いた。
はい。
複数の開発者で同一の環境で開発できるので防げる。

2. ローカルで通ったテストがCIでコケる。
開発と同一の環境でテストできるので防げる。
bundle install, npm installに失敗してテストがコケる。

3. 依存ライブラリのフェッチに成功したイメージでテストすることで防げる。
コードを変更していないのにアプリケーションの挙動が変わった。go getしてるライブラリの挙動がいつの間にか変わってたぽい。

4. 依存ライブラリをフェッチしたイメージを共有することで、バージョンを固定できる。
nginxの設定を変更したい。サーバにログインするためのSSHキーどれだっけ。
手元で設定して動作を確認しDockerイメージをデプロイすることができるので、設定変更のためにサーバーにログインする必要がなくなる。
さらに、正しく設定できているかブラックボックステストすることも可能に。

**デメリット**

- 学習コスト
コンテナーを立ち上げるあたりまではコスト低めだが、実際に開発環境としてDockerを使うあたりから「これどうやってやるんだろう」「どちらの方法で設定するのが良いのだろう」のノウハウが出てくる感じになる。
開発者全員に深い知識が必要かというとそうではないが、問題解決できる知識を持った人間が開発陣に最低一人は必要。

- ローカルでの開発とほぼ遜色ない環境でコードを書くことができるということを周知するためのコスト

- 完全な分離ではない。

---

## DockerFile とは(カスタムイメージを作成した時)

docker build で**カスタムimage**を作成するファイル
**公開されている Docker イメージをそのまま使う場合は必要なく、カスタマイズしたい場合に作成する。**

必要な理由
ベースとなるイメージとそのイメージに対して、どのような操作をするのかを記したDockerfileと呼ばれるファイルを用意しそのDockerfile通りにコンテナーに対して変更やファイルコピーを加えることによってイメージを作成する。

## カスタムイメージの作り方

2つある。

1. コンテナーから作る
ベースとなるイメージからコンテナーを起動し、そのコンテナーに対して、`docker exec`でシェルで入って操作したり`dokcer cp`でファイルをコピーしたりし調整を加える。
その後`docker commit`コマンドを使いイメージ化する。
**デメリットが存在する**


2. Dockerfileから作る
ベースとなるイメージとそのイメージに対して、どのような操作をするのかを記したDockerfileと呼ばれるファイルを用意しそのDockerfile通りにコンテナーに対して変更やファイルコピーを加えることによってイメージを作成する。
イメージの作成には`docker build`を実行する。

**メリット**
Dockerfileは、ベースとなるイメージに対する変更指示をまとめたファイル。これを見れば悪意ある操作や間違った操作が加えられていないかが一目瞭然
Dockerfileは改良しやすいメリットがある。

---

## Dockerfileでカスタムを利用した理由

ある程度なんでもしたいときはdebianイメージを使用することが多い。


## コンテナーからイメージを作る(docker cpやexecで中に入ったあと)

以前のhttpdコンテナーを作ったあと、`docker cp`コマンドをつかってindex.htmlをコンテナー内にコピーしhttp://でアクセスした時に、そのファイルの内容を見れるようにした。
これと同様の方法で作成したコンテナーをイメージ化する。
そしてそのイメージからコンテナーを作り直すことでindex.htmlがすでに入ったコンテナーが起動することを確認する。

コンテナーをイメージ化する
`docker commit`

## コンテナーからイメージを作る(Dockerfile)

- イメージに含めるファイル群とDockerfileの用意
イメージに含めたいファイルとDockerfileを1つのディレクトリに置き、それを`docker build`して作るという方法
※このディレクトリに含めているファイルはイメージを作成したとき、利用していないものであっても含まれてしまうため余計なものは置かない。
※ただし、同ディレクトリに.dockerignoreを置くと、除外ファイルを指定できる。しかしこの機能はファイル名のマッチングで除外をするためファイル数が多いと、イメージの作成に時間がかかってしまう恐れがある。


---

## レイヤー

Layerは`RUN / COPY / ADD`でのみ作成され、それ以外は一時的なLayerとして作成されます。（つまり無闇にこれらのステートメントを小分けにせず可能な限りまとめて記述 && で接続する 事も重要）

どのようなレイヤーで構成されているかは`docker history`で確認できる。  
Docker ImageはUnionFS という複数のFS（Layer）にあるファイルを透過的に一つのものとして扱う技術が使われ、Dockerfileの命令によって作成された全ての中間Layerをマージして最終的に一つのFSとなる。



---

## docker-compose.yml 覚書

コンテナーの定義やマッピングするポートなどコンテナーに関する設定を記述するファイル

```yml
version: "3"
services:
  app:
    # 起動イメージ
    image: node:16
    # 環境変数
    environment:
      - DEBUG=app:*
    tty: true
    # ホスト側のポート：コンテナーのポート
    ports:
      - "3000:3000"
    # ホスト側のsrcをコンテナーのappにマウント
    volumes:
      - ./src:/app
    # 起動時のカレントフォルダ
    working_dir: /app
    # 起動後に実行するコマンド
    command: npm start
```

> 重要な箇所は # ホスト側の src をコンテナーの app にマウントの部分で、通常 Docker コンテナーを停止するとコンテナー上で作成した各種ファイルは削除されますが、上記の記述を行うことでコンテナー起動時に再度ファイルがマウント（反映）されます。
> また Docker コンテナー上で作成・変更したファイルもこちらに記述した場所に反映される。
> 基本ホスト上とコンテナー上でファイルの同期をとるための記述と考えれば OK

## Docker compose 起動 (docker-compose コマンドについて)

`$ docker-compose run --rm app /bin/bash`

※rm オプションは Docker コンテナー停止時にコンテナーを削除する機能で、停止したコンテナーが残り続ける問題を解決するためのオプション

## Docker コンテナーの軽量化

[軽量化参考 URL](https://qiita.com/Canon11/items/da3a7795d894030865f7)

- コンテナーイメージサイズが大きいことによる弊害
  イメージのビルド時間が長い
  イメージを`Docker registory`にプッシュする時間が長い
  イメージを`PULL`する時間が長い

それらが起因して下記の弊害が起こる

トライアンドエラーに時間がかかり、生産性が低下
ビルド時間,CI 時間の増大
オートスケールでコンテナーがサービスインされるまでの時間が長くなる。
Kubernetes クラスタを構成する Node ディスクの消費

- 軽量化のアプローチ

1. RUN 命令をまとめる
   基本中の基本

※RUN 命令が走る度にイメージレイヤーが生成されてしまうため、ちょっと重くなる。

```dockerfile
# npm installの後のパッケージを羅列
RUN npm install -g gulp@3.9.1 \
    && npm install gulp-load-plugins \
    gulp-plumber \
    gulp-sass \
    gulp-pleeease \
    gulp-uglify \
    gulp-rename \
    && npm init -y
```

> このように、複数の RUN コマンドを「連続で実行する 1 つのコマンド」として扱うことで、イメージレイヤーをまとめて軽量化できます。

2. RUN で apt コマンドを走らせた場合はインストール時に使った apt キャッシュ(ゴミファイル)が残ってしまうため削除する。

3. 使用したい image に slim version があるか DockerHub で探す。
   ※デフォルトの NOde がかなり色々入っている。そのため slim イメージを探す。

---

## docker Script関連

## Docker コンテナーの動作に必要な設定を起動時に渡す

Dockerコンテナーを起動するタイミングで、コンテナーの動作に必要な設定を受け渡す方法は2つある。

1. 環境変数を通して渡す
2. コマンドライン引数を渡して渡す。

**どちらの場合も docker run で実行するコマンドの中に設定を含めることになる。**

## docker-entrypoint.sh

dockerで**初回起動時のみ特定の処理を行うヘルパースクリプト**
`docker run`とか`docker-compose up -d`などの初回起動時のみ処理したいことがある場合に使用する。

docker restart とか docker-compose restart とか systemctl restart docker の時には動いてほしくないんだ。
やってみた結果 mariadb + zabbix で初回起動時のみ、構成用の .sql を流し込む。という動作ができるようになりました。


---

## ローカル上にLocalStackをDockerで実行

開発用にAWSのサービスをローカル環境に構築できる、LocalStackというプロジェクトがある。素晴らしい。

[参考URL](https://qiita.com/mmclsntr/items/709863ba98a4855988f3)

## ビルドコンテキスト

ビルドコンテキストとは`docker build`実行時に指定するディレクトリのこと。  
`docker build`コマンドを実行した構築時、ビルドコンテキストとして現在のディレクトリ以下にある全てのファイルやディレクトリをDockerデーモンに送信してしまう。  
このような事態を防ぐためにもDockerfile用のディレクトリを作成し、そのディレクトリには無駄なファイルは配置しないようにすべき。

## Dockerのコンテキストとは

>docker build コマンドを実行したときの、カレントなワーキングディレクトリのことを ビルドコンテキスト（build context）と呼びます。 デフォルトで Dockerfile は、カレントなワーキングディレクトリにあるものとみなされます。 ただしファイルフラグ（-f）を使って別のディレクトリとすることもできます。 Dockerfile が実際にどこにあったとしても、カレントディレクトリ配下にあるファイルやディレクトリの内容がすべて、ビルドコンテキストとして Docker デーモンに送られることになります。

要は**docker buildコマンドを実行した場所**

- 制約
**Dockerはコンテキスト(カレントディレクトリ)の外のファイルにはアクセスできない仕様。**

- ではディレクトリごとにわけた
ルートディレクトリをDockerのコンテキストにすることで、Dockerfileはどんなファイルにもアクセスできるようになりました。
一方で、build時はその分Dockerデーモンという奴にそれだけ多くのファイルを送ることになるので遅くなることがあるようです。

構築時、ビルドコンテキストとして現在のディレクトリ以下にある全てのファイルやディレクトリをDocker deamonに送信してしまいます。ビルドコンテキストに余分なディレクトリ・ファイルがあると、build時に時間がかかる、メモリを消費する原因となります。たとえば、ビルドコンテキストに100MBのファイルがあるとimageのサイズが100MBプラスとなってしまいます。このような事態を防ぐためにも**Dokcerfile用のディレクトリを作成し、そのディレクトリには無駄なファイルは配置しないようにすべきです。**

## .dockerignore

dockerignoreとは、DockerfileのCOPYコマンドでコピーしたくないファイルやディレクトリを指定するファイルのこと。  
dockerignoreを作成することで、ビルド時間の短縮、docker imageサイズの最適化などの効果があります。

仕組み
>Dockerfileからイメージをビルドする場合、Dockerfileの存在するディレクトリの中身はtarで固められdaemonへと送られます。DockerfileのCOPYコマンドを使用して、必要なファイルをコピーします。

## docker network

コンテナー内の/etc/hostファイルで定義されているそう。以外に簡単

## マルチステージビルド

[参考URL](https://qiita.com/carimatics/items/01663d32bf9983cfbcfe)

- マルチステージビルド以前
サイズを小さく保ちながらDockerイメージをビルドすることは、最もやりがいのあることのひとつ　。
**Dockerfile内の各々の命令ではイメージにレイヤが追加される。**
**したがって、次のレイヤを作成する(次の命令に移る)前に、不要な生成物のクリーンアップする必要があります。**
本当に効率的なDockerfileを作成するには、レイヤをできる限り小さく保ち、各レイヤが前のレイヤの生成物から必要なものを確保するために、シェルのトリックやその他のロジックを採用する必要がありました。
実際に、開発用にはアプリケーションのビルドに必要なすべてが含まれるDockerfileを使用し、プロダクト用にはアプリケーションおよび実行に必要なもののみが含まれるスリム化されたDockerfileを使用することは非常に一般的でした。
これがいわゆる"ビルダーパターン"です。
2つのDockerfilesを保守することは、理想的ではありません。

---

## ここからはさわって学ぶクラウドインフラ本

- コンテナー
コンテナーはシステムの実行環境を隔離した空間のこと。
アプリケーションの実行に必要なプログラムやライブラリ、**各種設定ファイルなどをワンパッケージにし隔離して実行するための仕組み。**
コンテナーのメリットはそれをコピーして別のコンピューターーで動かすのが容易なこと。

システム開発・運用の現場では、「開発者が作ったプログラム一式を検証機にコピーする」「検証機で動作確認して問題なければ本番機にコピーする」「冗長性や負荷分散のために、同じ構成のものコピーして多数台用意する」というように、そのコピーを作りたいことが、よくある。
コンテナー技術を使えば操作が容易になり、コピーや設定漏れを防げます。またシステムのアップデートも、コンテナーを差し替えるだけで済むようになります。

## Docker イメージ

2種類
Dockerイメージには基本的なディストリビューションとアプリケーション入りのがある。
**カスタマイズするには基本的なディストリビューション入り(Linuxのみ)を使う**

Dockerイメージに手を加える時は、アプリケーション入りDockerイメージではなく、LinuxのみDockerイメージをベースとするほうがやりやすい。
→ただ、そうしたカスタムは手間がかかり、1つひとつ手作業していると作業漏れが起こる可能性が少なくない。そこでコンテナーに手を加えたあと、**そのコンテナーをカスタムDockerイメージに変換する。**


- ではカスタムのDockerイメージを作るのは？
カスタムのDockerイメージを作るときは、手作業でファイルコピーやコマンドを実行するのではなく、Dockerfileにファイルコピーや実行したいコマンドなど一連の設定を記述し、そのファイルを適用して作るのが一般的。
**カスタムDockerイメージはDocker HubのようなDockerレジストリに登録できる。**

## Docker desctop

Docker Desctopの内部にはLinuxカーネルが含まれており、WindowsやmacOSでありながらもLinuxを実行することで、その上でDockerを使えるようにしたもの。

## 仮想サーバとコンテナーの違い

仮想サーバは1台の物理的なサーバの中に復数の仮想的なサーバを作り、**物理的なサーバを仮想的なサーバが分割して使う**

コンテナーはサーバをブナkつする技術ではない。**サーバはあくまでも1台で、その中にたくさんのアプリケーションが隔離して実行されているのにすぎない。**

## コンテナーの破棄

docker stopしてもコンテナーはずっと残り続けるということ。
**これは明らかにディスクを圧迫する。もう使わない場合は停止ではなく明示的に破棄にするべき**
docker rm で完全削除できる。

## イメージの破棄

Dockerイメージが消費する容量も馬鹿にならない。
**ダウンロードしたイメージはコンテナーを破棄しても残ったまま。**
※これはもう一度、同じDockerイメージからコンテナーを作ろうとした時に、再ダウンロードしなくても済むようにするため。

`$docker image ls`
`$docker image rm` → `$docker rmi`とかける。


## docker runについて

`$docker run`というコマンドは

`$docker pull`,`$docker create`,`$docker start`という3つの一連のコマンドをまとめて実行している。

使い方
`$ docker run [オプション] イメージ [コマンド] [引数...]`

## タグ

イメージ名のタグ(tag)はDockerイメージの製作者が名付けた分類名のこと。
**※タグはリソース版や、開発版、バージョン番号などを示すのに使われる。**

タグ名を省略する時は、最新版を意味する**latest**というタグが指定されたものとみなされる。

## オプション

### -pオプション(略称 publish)

ポート番号をマッピングするもの
`-p ホストのポート番号:コンテナーのポート番号`
udpを選択する場合には、ポート番号を`ポート番号/udp`とする。
**※Dockerでは、pオプションを指定しない限り、DockerホストとDockerコンテナーとの通信は繋がらない。**
**※マッピングの状態は`docker port `コマンドで確認ができる。**

### -vオプション

コンテナーの特定のディレクトリにホストのディレクトリをマウントする設定。
**-mountオプションを同様**

`-v ホストのディレクトリ:コンテナーのディレクトリ`

## -ditオプション

-ditは` -d, -i, -t`の3つのオプションの組み合わせ。

-dが端末から切り離してバックグラウンドで実行
-iと-tはコンテナーを端末(キーボードとディスプレイ)から操作するためのオプション

アタッチの場合(-dを指定しない時)は端末と接続された状態のため、端末からの操作は、そのままコンテナー内で実行中の既定のコマンドに流されます。だからこそ、［Ctrl］＋［C］を押すことで、そのコマンドが終了する。
デタッチのときは、端末とは切り離されているので、コンテナー内で実行されているコマンドに対して、何かキー操作することはできません。デタッチの状態とアタッチの状態は、実行中に切り替えることができる。


## -iオプション

標準入出力およびエラー出力をコンテナーに対して結びつけます。その結果、キー入力した文字はコンテナーに渡され、コンテナーからの出力が画面に表示されるようになります。iオプションを指定しないと、キー入力はコンテナーに伝わりませんからこうしたキーが効きません。そしてコンテナーからの出力が届きませんから、httpdコンテナーの例で言えば、いま見てきたように、画面に各種ログが表示されることもありません。

## -tオプション

-tオプションは、pseudottyと呼ばれる疑似端末を有効にする設定です。疑似端末は、カーソルキーやエスケープキー、［Ctrl］キーなどで操作するためのものです。このオプションを指定せず、iオプションのみだと、これらのキーが使えません。つまり、［Ctrl］＋［P］、［Ctrl］＋［Q］キーが効きません。

デタッチで起動後、操作の必要がないのであれば-iや-tのオプションは必要ない。
しかし、後でアタッチするなどして端末から操作したいときは-iや-tを指定する必要がある。

---

## Volume関連

**ボリュームマウント**
ボリュームとは、Dockerコンテナーーで扱うデータを永続化する仕組み。
Dockerの中にボリュームというデータを保持する領域を確保し永続化する。
HOSTでソースコードなどを変更する必要がないのであれば、ファイル類をすべてコンテナ内管理する。
具体的にはボリュームマウントしたフォルダでファイルを管理するのがベスト。
問題は、ボリュームマウントしたファイルは**HOSTから直接操作できないのが難点。**
ですので、ソースコードを変更しなければならない開発環境で使うのは難しいです。
また、HOSTで自由に読み書きできないので、バックアップをとるのもちょっと面倒。
docker snapshotみたいな機能があればいいんですが…現状はないっぽいです。

因みに、VSCodeであれば、拡張機能を使うことによってボリューム内のファイルの読み書きが可能です。

これから新規に開発環境を作るのであれば、VSCodeを使うことを前提にボリュームマウントを使うことをお勧めします。




**バインドマウント**
ホスト側のディレクトリやファイルをコンテナーー内にマウントすること。
バインドマウントによってもコンテナーーで扱うデータを永続化できる。
※ただしDockerDesktopを使用していると、LinuxのVMを経由して動作させる必要があるためファイルアクセスのパフォーマンスが低下する可能性。そのため`:cached`を追加してバインドする。

バインドマウントでマウントキャッシュを利用してホストマシン上のディレクトリをビルド中のコンテナ内にマウントすると、ファイルの**uid, git, modeはコンテナ内でファイルを作成するとrootとして操作したこと**になり、ファイルは`uid=0`で作成される。

もしそれがホストマシン上のディレクトリをマウントした場所なら、ホストマシン上のディレクトリにuid=0のファイルが作成されることになります。ファイルのownerやパーミッションの値に注意しましょう。



**バインドマウントの注意**
マウントするボリュームに何かしらファイルやディレクトリが存在すれば、マウントされるコンテナーー側のディレクトリの中身は全部上書きされる。
マウントするボリュームに何も入っていなくて、マウントされるコンテナーー側のディレクトリに何か入っていれば、ボリュームにコピーされる。

## docker内のファイルと永続化

Dockerコンテナーは、それぞれが隔離された実行環境。**コンテナーを破棄すればその中にあるファイルは自ずと失われる。**
`$docker rm`このコマンドをして再度`docker run`をするとコンテナーIDが変わるとおもう。前のコンテナーとは別のものとなっている証拠。

## ホストからファイルをコピーする

コンテナーーの中のファイルを変更するにはどのようにすればいいか

docker execで、/bin/bashを起動しそこでnanoエディターなどを起動して、編集する方法。
しかしapacheなどではファイルサイズを小さくするためnanoエディターなどが入っていないおそれ

そこで便利なのが`docker cp`コマンド
※docker cpはパーミッションをそのままコピーする。ディレクトリも再帰的にコピーする。
※docker cpは/prop, /sys, /dev, tmpfs配下のようなシステムファイルはコピーできない。**こうしたファイルをコピーしたい時には標準入出力経由でコピーする。**

## 上記を含めると、コンテナーーは一度起動したら破棄してはいけないのか？

違う。そうではなく**コンテナーーで失ってはいけないデータは外に出すように設計する。**

- ではどうすればいいか？

**マウントする。**
コンテナーーは実行するシステムと扱うデータは別に管理することが推奨されている。
またコンテナーーの設計として**実行するシステムと扱うデータは別に管理することが推奨されている。**

`docker run -v`でマウントをする。

ボリュームのマウントにはバインドマウントと同様にvオプションを使う。
**違うのはディレクトリ名ではなくボリューム名を使うという点だけ**

注意
**ただしボリュームのマウントにはvオプションではなく、mountオプションを使うことが推奨されている。**vオプションだとボリュームが作られていない時に新規にボリュームが作成されてしまい、意図しない結果になるため。

つまりデータをコンテナーーの外に出す。
**Dockerホストのディレクトリをマウントしているのは(外に出しているのと同意)そのためコンテナーーを削除しても消えないのは当たり前**


---

## mountオプションを使ったマウントの設定

バインドマウントやボリュームマウントするのに-vオプションを使っていたがもう1つ--mountというオプションを使う方法もある。

`--mount type=マウントの種類, src=マウント元, dst=マウント先`

マウントの種類は、バインドマウントのときはbind, ボリュームマウントのときはvolumeを指定する。
srcはマウント元、dstはマウント先(srcはsource, dstはdestinationやtargetとも書ける。)

--mountはDocker17.06からサポートされたオプション。--mountのほうが推奨されている。

1. バインドマウントかボリュームマウントかわかりにく。
-vオプションではマウント元が [ / ]から始まる時はバインドマウント、そうではないときはボリュームマウント。

2. ボリュームが存在しない時はエラーを吐く。


---

## コンテナー間のデータ共有にも利用できる。

マウントする手法はデータを失わないようにするだけではなく、別の方法もある。
**それはコンテナー間でのデータ共有。1つの場所を2以上のコンテナーで同時にマウントすることもできる。**

そのため./docker/nginx/nginx.confなど、設定ファイルをプロジェクトに用意しているのは、コンテナー内のnginxの設定ディレクトリにマウントし本来のnginx.confを上書きしている。
この方法であれば、Dockerホストに設定ファイルが残るため設定のバックアップが容易。

※マウントはディレクトリに対して設定するのがほとんどだが、設定ファイルだけをマウントすることも可能。

Dockerホストにあらかじめディレクトリを作っておき、それをマウントする方法を**バインドマウントという**

- マウント種類

**バインドマウント**
Dockerホストにあらかじめディレクトリを作っておき、それをマウントする方法を**バインドマウントという**
ディレクトリの変更をDockerコンテナに反映したいとき（アプリケーション用のコンテナなど）


**ボリュームマウント**
ボリュームマウントは、ホスト上のディレクトリではなく、**DockerEngine上で確保した領域をマウントする方法。**
確保した場所のことを、データボリュームもしくは略してボリュームと言う。

**データベース用のコンテナなど**

>ボリュームを使う利点は、ボリュームの保存場所がDockerEngineで管理されるため、その物理的な位置を意識する必要がなくなるという点。ディレクトリ構造はDockerホストの構成によって違うので、ディレクトリ名で指定する場合（dockerrunやdockercreateのvオプションでディレクトリを指定する場合）は、Dockerホストに合わせた場所を指定しなければならず、汎用的ではありません（たとえば、ある管理者は/home以下を使うように構成したかもしれませんし、別の管理者は/var以下を使うように構成したかもしれません）。それに対して、ボリュームを扱う方法は汎用的で、どのDockerホストでも同じです。すぐあとに見るように、dockercreateでボリュームを作るコマンド、そしてそのボリュームをdockerrunやdockercreateで指定するためのオプションは、どのDockerホストでも同じです。

ボリュームマウントはブラックボックス。そのためDockerホストから変更できない。


汎用性という目でいうと、ボリュームマウントが推奨されるが、バインドマウントを完全に置き換えるわけではない。
バインドマウントのほうが優れている場面もある。

## バインドマウントのがよい場面

1. 設定ファイルの受け渡し
Dockerホスト上に設定ファイルを置いたディレクトリを用意して、それをコンテナーに渡したい場合です。

2. 作業ディレクトリの変更を即座にDockerコンテナーから参照したいとき
Dockerホスト上のファイルを変更したとき、それをDockerコンテナーにすぐに反映させたいときです。たとえば、httpdコンテナーを動かして、そのドキュメントルート（/usr/local/apache/htdocs）を、これまでのように、Dockerホストの適当なディレクトリにバインドした場合、Dockerホスト側でそのディレクトリ内のファイルを変更すれば、それはすぐにDockerコンテナーに反映されます。

3. 各自のPCでDockerを使う場合はバインドマウントが便利

## ボリュームマウントのほうがよい場面

ボリュームマウントが向く場面、Dockerコンテナーが扱うデータをブラックボックスとして扱い、**コンテナーを破棄してもデータが残るようにしたいだけの場面。**

データベースのデータは、通常ひとまとめのブラックボックスとして扱い、**それぞれのファイルをDockerホストから編集することはないはず。**もしそんなことをしたら、データベースは壊れてしまうことでしょう。**このようにDockerホストから不用意にデータを書き換えたくない場面では、ボリュームマウントが向きます**
※ボリュームはデフォルトでは、Dockerホスト上のストレージですが、**ボリュームプラグインをインストールすることで、AWSのS3ストレージやNFSなどのネットワークストレージを用いることもできます。**


## ボリューム作成手順(MySQL)

1. ボリュームを作成する(mysqlvolumeという名前)
`$docker volume create mysqlvolume`

2. 作成したボリュームを確認する
`$docker volume ls`
DRIVER   VOLUME NAME
local    mysqlvolume

※dockervolumelsの結果として表示される「DRIVER」は、ボリュームを構成するドライバです。既定は「local」であり、Dockerホスト上のディスク上に作成される。それ以外にボリュームプラグインをインストールすることでAmazon S3のストレージやNFSなどのネットワークストレージを利用できる。

## tmpfs

`$docker run --mount type=tmpfs, dst=マウント先`

tmpfsはディスクではなく、メモリーを特定のマウント先に指定するものでメモリーディスクを利用することで読み書きを高速化する目的で使う。
tmpfsはメモリーのため揮発性。コンテナーを破棄することでなくなる。

## データのバックアップ

バインドマウントの場合はDockerホスト上のファイルのためDockerホストで別のディレクトリにコピーするか、tarコマンドでまとめて保存するなどでバックアップができる。

- ボリュームの場合は？
ボリュームの詳細情報は`$docker volume inspect ボリューム名`で見れる。
この場所をtarで固めても意味がない

## ボリュームのバックアップの考え方

ボリュームの場合は適当なコンテナーに割り当てて、そのコンテナーを使ってバックアップを取るようにする。


---

## Docker のネットワーク

Dockerのネットワークは大別するとnone, host, bridghという3つの構成を取ることができる。

[参考URL](https://tech-lab.sios.jp/archives/20179)





## 本番運用

本番の安全運用は、Dockerホストをマネージドサービスにしてある程度、任せてしまうのが無難。
AWSにはAmazon ECSというコンテナーを運用するマネージドサービスがある。

- マネージドサービス
管理されたManagedサービスという意味で、**運用管理をクラウドに任せることができるサービスのことを言う。**
仮想サーバのEC2は自分で管理するサービスのためアンマネージドサービスという。

- さらなるスケーリングや堅牢性がほしいときはKubernetesを使う。

- どのイメージをダウンロードすればいいのか
納品にあたっては、動作検証するはず、動作検証後にコンテナーのバージョンが変わるということはシステムが変わること。
本番環境でDockerを利用するのであれば、タグ名を省略せずに明示的に指定して、特定のイメージの版に利用する(それよりも新しい版ができたとしても使わないようにする。)
**もちろん、その特定イメージの版のまま使い続けるという意味ではありません。**ある程度の期間が経ったら、そのときの最新版で再度動作検証し、問題なければ、その版に差し替えるというように、コンテナーの定期的なアップデートは必須です（そうしなければ、脆弱性などに対応できない。

- Dockerイメージを使う場合
そのイメージの製作者が**どのような使い方を想定して作っているのか、各種設定はどのようにして行えばいいのか**を記載されているドキュメントから汲み取らなければならない。
かいつまんででもいいので下に記す。

１. マウントすべきディレクトリを知る
**データベースのデータは、/var/lib/mysqlディレクトリに保存されます。ここをボリュームマウント（もしくはバインドマウント）することで、コンテナーを破棄しても、データベースの内容が失われないようにする。**

2. rootユーザのユーザ名、パスワード、規定のデータベース名などの指定方法
データベースにアクセスする際のrootユーザーのユーザー名、パスワード、既定のデータベースなどは、**環境変数として引き渡します**
`docker run -e [環境変数]`
※もっと複雑な設定をしたい時は、MySQLの設定ファイルであるmy.cnfをファイルをバインドマウントで引き渡す方法もとれる。

## Docker build

Dokerfile から docker image を作成するコマンド

`$docker build`

build後、`docker history`で作成されたイメージの詳細情報が確認できる。

**ビルド後のイメージを利用する**

`docker run`をすれば利用できる。


---

## Dockerfile覚書

[COPY]
コピー元はDockerfileファイルが置かれている場所からの相対パス
コピー先はWORKDIR命令で指定したパスからの相対パス


### RUN

RUNコマンドは、docker buildするタイミング(すなわちイメージを生成するとき)に実行している。ここにはイメージの時点で実行しておきたいコマンドを書く。
例としてはソフトウェアパッケージのインストールやファイルのコピー、変更などの処理。

※注意
**RUN命令は複数のコマンドを実行するときも、できるだけ1つのRUNコマンドで済ませるようにする。**

## CMDとENTRYPOINT

docker runやdocker createの引数で指定したコマンドが終了するとコンテナー自身が終了する挙動だったことを思い出す。
service httpd startを実行した場合は、httpdをバックグラウンドで実行してserviceコマンド自体はすぐに終了する。
その結果、コンテナー自体がすぐに終了してしまう。
コンテナーを動かしっぱなしにしたいのであれば、CMDやENTRYPOINTは**ずっと動きっぱなしでいるコマンドを指定する**

CMDとENTRYPOINTを指定しない場合は、ベースイメージの設定値が引き継がれる。
**※なおCMDとENTRYPOINTはDockerfileに1つしか記述ができない。複数記述ができれば、もっとも後ろにある設定が採用されそれ以外は無視される。**

CMDとENTRYPOINTはコンテナーを起動したときのタイミング(docker startやdocker runするときのタイミングで)コンテナーの中で実行するコマンドを指定するもの
※`docker run`ではコンテナーの中で実行するコマンドを指定し、そのコマンドが終了するとコンテナーが終了するという仕組みだったことを思い出す。

- ENTRYPOINT
指定した場合、docker runの最後に指定するコマンドは、このENTRYPOINTで指定したコマンドへの引数となる。

- CMD

## EXPOSE

`docker run`する際、**-pオプションだけを指定し、ポート番号を省略した時にEXPOSEで指定したポートのマッピングが行なわれるようになる。**

## ARG [変数名]

Dockerfile内で使用する変数名を指定する。
docker-compose.yml内で指定するのが入ってくる。

## ENV[変数名=値]

Dockerイメージで使用する環境変数を指定する。
ENVを使って設定した環境変数はイメージからコンテナーへ渡させる。
コンテナーへ渡させると、コンテナー内で起動したアプリケーションで参照することができる。

**ENVを使って設定した環境変数はイメージからコンテナーへ渡せる**

## apk

[参考URL](https://kleinblog.net/alpine-apk-cmd.html)

Alpine Linuxで使用できるパッケージ管理コマンド（Alpine Linux package managementの略）
Linuxコマンドのapt-getが使用される場合は、ベースイメージがAlpineではないということ。


---

## Dockerfileとキャッシュ

docker buildはDockerfileに1行1行のビルド行程をキャッシュする。
そしてそこまでに変更がなければキャッシュが使われる。

`docker build`する際、キャッシュを使うかどうかは次の基準で決まる。

1. FROMで指定しているベースイメージのキャッシュが変わった
2. Dockerfile自体の命令が変わった
3. ADDやCOPYしているファイルの対象が変わった

キャッシュ判断されないもの
たとえば、aptコマンドでApacheやPHPのパッケージをインストールしているが、**ApacheやPHPのパッケージがアップデートされたかどうかは、キャッシュの判断基準ではない。**
RUNコマンドでどこかからのサイトからのファイルをダウンロードしている場合、その対象ファイルが更新されたかどうかまでを判定するものでありません。

## キャッシュを活用してビルドを高速化する

たくさんのパッケージをインストールし、内部でコンパイルするようなコンテナーを作ると、docker buildするときとても時間がかかる。
そのような時は、キャッシュを活用すると高速化できる。
**RUNコマンドをあえて複数に分ける。そこで別のキャッシュが作られるため、変更されていない部分はそのRUNコマンドの実行を飛ばすことができ高速化できる。**

## Dockerをさらに早める

Docker Daemonへの転送ファイル削除

## Docker image指定

```Dockerfile
FROM [:TAG|@DIGEST]
```

DIGEST
ダイジェストを使うとimageを特定できる。
`$ docker image ls --digests`で表示が可能。

v2以降の形式を使うイメージには、digestと呼ばれる識別子が振られている。
ダイジェスト値は、イメージ生成後に変更が加えられれば値は変わる。

---

## Docker クリーンアップ

[参考URL](https://docs.docker.jp/config/pruning.html#docker-prune)

Dockerは使用していないオブジェクト(イメージ・コンテナー・ボリューム・ネットワーク)に対するクリーンアップには慎重なアプローチを取っている。
※すなわち各オブジェクトをDockerに対して明示的に削除を命令しない限り、削除はしない。
→その結果Dockerは巨大なディスク容量を使うことになった。


## dangling image(宙ぶらりイメージ) : ダングリングイメージ

[参考URL](https://codechord.com/2019/08/docker-images-none-dangling/)

- latestタグ
これは最新のイメージを意味し、現在使用しているイメージとなる

- noneタグ
noneタグとは、同じイメージの中で、最新ではないイメージを指す。

Dockerはイメージを作り替えると、過去のイメージを保管したまま新たなイメージを作成する。
これではどんどんイメージが蓄積され、 PCのメモリを大きく消費してしまう。

**dangling状態のイメージは特別な理由がない場合には不要。**

`<none>`とは何？
Dockerでは同一名のイメージを複数作成することができない。
すでに存在するイメージと同一名のDockerイメージを作成しようとした場合は、次のような挙動となる。

最新のビルド結果のイメージが、指定のイメージ名称となる。(上記例の場合はABCDEFG)
すでに存在していた同一名称のイメージは、`<none>`という名称未設定の状態に置き換わる
この症状のことを、dangling（宙ぶらりん）という。

削除後、`<none>`のimageが消えている。

```sh
$ docker images
REPOSITORY                       TAG           IMAGE ID       CREATED          SIZE
neams_api                        latest        f86551e138bc   11 minutes ago   600MB
neams_front                      latest        a665671491c1   12 hours ago     589MB
wordpress                        latest        b6306a6a7068   4 weeks ago      616MB
mysql                            5.7           738e7101490b   6 weeks ago      448MB
doc_swagger-merger               latest        6421e7fee9e3   6 months ago     118MB
```

## コンテナーのprune

コンテナーを停止しても`--rm`フラグを付けて起動していなければコンテナーは自動に削除されない。
停止しているコンテナーの書き込み可能なレイヤーは、ディスク容量を消費し続ける。
これらを綺麗に片付けるには`$ docker container prune`コマンドを使用する。

---

## Docker コア数確認

```sh
# コンテナーに入る
$ docker-compose run --rm [service name] /bin/sh

# コア数確認
$ nproc
2
```

## Docker log ディレクトリ確認

[参考URL](https://it-web-life.com/docker_container_log_clear/)

## Tips

Docker Buildにおけるリードタイム短縮
[参考URL](https://tech.plaid.co.jp/improve_docker_build_efficiency/)

Dockerイメージ分析ツール
[dive](https://kotaroooo0-dev.hatenablog.com/entry/2020/07/28/205931)

[Docker内のブラウザをホストで起動する](https://takapi86.hatenablog.com/entry/2019/03/24/144008)

---

## docker image選び

[参考URL](https://www.ted027.com/post/docker-debian-difference/)

利用するDocker imageを選ぶ際に、同じバージョンであっても後ろに-stretchやら、-busterやらがついていて迷うことがある。
これは**imageがベースとしているOSの種類によるもの**です。

### stretch/buster/jessie/bullseye

これらの文字列がついたimageは、それぞれ同名のDebian Releaseをベースに構築されたものです。
コードが特定のDebian Releaseやバージョンと互換性を持つ特殊な場合を覗いて、基本的にどれを選んでも大差ありません。

### slim

`-slim`がついたimageは**フルイメージの下位互換バージョン**です。インストール済みのパッケージは使用頻度の高いものに限定され、その分軽量化されている。
軽量のimageが望ましい場合に採用する。
ただし前述のようにフルイメージに存在するパッケージが一部存在しないため、正しく動作するか十分なテストが必要。

## alpine

`-alpine`がついたimageは、Alpine Linuxをベースに構築されたもの。
Alpine Linuxは、コンテナーで利用することを想定して設計されたOSで、極めて軽量。
Alpineのベースイメージは5MB未満と非常に小さく収まっている。

コンテナーを可能な限り**最小で最速で構築したい場合**に採用が適してる。

一方で欠点もあります。ベースOSが大きく異なるため、主要なパッケージ、コマンドのいくつかがないか、あるいは類似の別のものを利用する必要があります。  
たとえば、aptの代わりにapkでパッケージをインストール（結構古いバージョンがが入ります）、glibcでなくmusl libが入っている、等。 また、一部Debianとの互換性を持つPythonパッケージは、Alpineベースのimageで動作するように再コンパイルしなければ動作しません。

とはいえ、それが大きな問題にならないのであれば、フルイメージを使うよりも、alpine imageにapkで必要なパッケージのみをインストールして利用した方が、軽量かつ高速で環境を構築できます。  
ただし、正常に挙動するか、入念なテストを行う必要があります。

### 結局どれ

- 十分なテストをする余裕がなく、環境を素早く立ち上げなければいけない場合、stretch, buster, jessie, bullseyeあたりを適当に選ぶ。

- コンテナーを軽量化する必要があり、最小限のパッケージだけで動作することが分かっていれば、slimを採用する。

- コンテナーを限界まで軽量化する必要があり、十分なテストが可能であればalpineを採用する。ただし、移植等した際に挙動がおかしくなる可能性がある。

- 頻繁にimageを取得するユースケースであれば、slimやalpineを優先的に採用する
私はCIを爆速で回したいのでalpineで頑張ってみるのが好きですが、すんなりうまく行くことは少なく、結局調べたり乗り込んでパッケージを入れたりしてやっとこさ成功する。

---

## scriptsに分ける

キャッシュを

## security

安全性を高めるために
**バイナリダウンロード元にチェックサムや署名などの情報があるのであれば**、Dockerfileの中で検証ロジックを入れておくと良い、

---

## M1 macでのdocker

[参考URL](https://zenn.dev/suzuki_hoge/books/2021-12-m1-docker-5ac3fe0b1c05de)

## Docker マルチCPUアーキテクチャ

[参考URL](https://dev.classmethod.jp/articles/docker-multi-architecture-image-build/)
[参考URL](https://gihyo.jp/dev/serial/01/mysql-road-construction-news/0167)

Docker Hubにおける**マルチCPUアーキテクチャサポート**とは、x86 (AMD64) やARM64など複数のアーキテクチャ向けのイメージを**同一のイメージ名・タグ名で管理する**ことができる仕組み
Docker Hubで公開されている公式イメージの多くはマルチCPUアーキテクチャに対応している。

公開されているイメージが「マルチCPUアーキテクチャ」に対応している場合、Docker Hubからプルを実行した際に、とくにアーキテクチャを明示しなくても自動的に適切なアーキテクチャのイメージがダウンロードされます。

```yml
db:
    # これを指定しなくてもM1であれば自動ダウンロード？
    platform: linux/amd64
    image: mysql:5.7
```

## health check

>実行するコマンドはコンテナが正常に稼動していれば終了コード「0」を、そうでなければ「1」を返すようになっている必要がある。これさえ守っていれば、実行するコマンドはバイナリでもスクリプトでも構わない。

