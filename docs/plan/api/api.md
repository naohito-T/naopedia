# API

[参考URL](https://www.infoq.com/jp/articles/ballerina-fullstack-rest-api/?itm_source=infoq&itm_medium=related_content_link&itm_campaign=relatedContent_news_clk)

## API種類

フロントエンドから直接機能されるAPIの開発には、**いくつかの一般的な選択肢が存在する**

1. REST API
2. GraphQL API
3. WebSocket API

## 上記のAPI種類が決まったら

- セキュアな通信か
- 認証は？
- 承認は？
- 監視、可観測性、ログ


## Web API

Web APIを設計する際に様々なものを作成するかと思うがそれを記載する。

---

## JWT(JSON Web Token)

[JWTを使った今どきのSPAの認証について](https://tech.hicustomer.jp/posts/modern-authentication-in-hosting-spa/)

**JWTを用いることでパスワードなどの認証情報をDBに保存する必用がない**というメリットがある

2つのパーティー間で情報を安全に送信するための方法→『二者間で情報のやりとりを目的とした、JSONベースの形式について規定した標準仕様』

実態は、**JSONオブジェクトをエンコードした文字列でこの文字列をトークンと呼ぶ。**

**3つの文字列がピリオドで連結されている**
JWTが発行したトークンは、ドットによって3つにわかれている
それぞれ**Base64でエンコードされた文字列**となっている.
`<ヘッダ>.<ペイロード>.<署名>`

- ヘッダ(署名の検証に必用な情報)
ここにはトークンのタイプや、使用されている署名アルゴリズムの情報を持っています。

```js
// エンコード => デコード
eyJhbGciOiJIUzI1NiJ9.
=> { "alg": "HS256", "typ": "JWT" }
```

- ペイロード(やり取りに必用な情報。ユーザー情報など)
2番目の文字列をペイロードと呼び、任意の情報を指定することができる。
**基本的には、このペイロードをカスタマイズしてユーザー認証に必要な情報を埋め込む**

```js
// エンコード => デコード
eyJleHAiOjE2MDA1OTY0MzEsInN1YiI6MSwibmFtZSI6InVzZXIwIn0.
=> {"exp"=>1600596431, "sub"=>1, "name"=>"user0"}
```

expやsubなどのそれぞれの値をクレームと呼ぶ
**デフォルトで指定されている値を予約クレーム、使用者が任意に指定した値をパブリッククレームと呼ぶ**

- 署名(検証する内容): 署名には秘密鍵を使うため、これをも用いて検証を行うことができる。
3番目の文字列には署名情報がある。
**この署名は、トークンが変更されていないか確認するために使用される。**

```js
// エンコード => デコード
lXcwASyLX5GEsMvPYDVhe0ovJj631fUiC0q2ojK-yK0
=> HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
)
```

## sub(Subject)クレーム

JWTの主語となる主体の識別子で予約クレームの一つ。
直訳すると「件名・主題」で、一般的にはオブジェクトを識別する一意性の値を指定します。
ユーザーテーブルで言うと、ユーザーIDのことです。
このクレームは任意で、{ user_id: 1 }と言ったペイロードでも問題ありません。
ただし、他アプリケーションとの衝突を避けるために予約クレームを使用することが推奨されています。

- 鍵の指定
トークンの発行には**署名時に使用する鍵が必要。**
この鍵が漏れると、誰でもトークンの発行と検証ができてしまうため非公開であるRailsのシークレットキーを使用する(Railsの場合)

発行手順

```sh
irb(main):001:0> payload = { sub: 1}
irb(main):002:0> secret_key = Rails.application.credentials.secret_key_base
irb(main):003:0> token = JWT.encode(payload, secret_key) # 暗号化し発行
irb(main):004:0> token
=> "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOjF9.0HBLImIKESioXrusu-yz4g53qpxrAahNyXRfgTQ5eJ0"
irb(main):005:0> JWT.decode(token, secret_key) # JWTをデコードする
=> [{"sub"=>1}, {"alg"=>"HS256"}]
```

## JWTのいいところ

1. JWTの最大のメリットは情報が改ざんできない
2. ユーザテーブルにトークンを保有するカラムを作成しなくてよくなる
この仕組みを認証に使えば、ユーザーテーブルにトークンを一時的に保有するカラムを作成しなくて良くなる。
3. トークン発行時に電子署名を付与することができるため、署名をした鍵を持つものしかトークンを検証することができない

>署名時に付けた鍵と同じ鍵を使って検証する署名アルゴリズムを「HS256」、
>秘密鍵と公開鍵のペアで検証する署名アルゴリズムを「RS256」

## JWTの注意点

トークンはエンコード(Base64) されているだけで暗号化はされていない。
トークンの中身は以下で見れてしまう

[jwt.io](https://jwt.io/introduction/)

**漏れたらまずい個人情報（メールアドレスなど）はトークンに埋め込まないように**しましょう。

## JWTの保存先

JWTの保存先には、**ローカルストレージがよく挙げられるがJavaScriptで簡単にアクセスできてしまう(XSS)**
認証に使用するJWTはログインメールアドレスとパスワードと同じ意味を持つため、**外部のJavaScriptからアクセスできない場所に保管することが望ましい。**
**そのためJWTをCookieｎ保存する。方法もある**

## JWTはCookieを使った認証の代わりにはならない

JWTの有効期間が切れた後に、再度ログイン画面を表示する必要がある。JWTが切れるたびにログイン情報を入力させるのは、Cookieを使用したステートフルな認証に比べてUXが劣る。

JWTは有効期間を長くすると危険。今回の用途だとJWTは、HttpOnly cookiesのようにJSからアクセスできない領域に保存できないため、常に漏洩のリスクと戦うことになる。npmの最近のCVEを見る限り、Third partyのJSライブラリを全て監査することは不可能。そのためあまり有効期限を長くできない。これはrefresh tokenの仕組みを使っても同じ。

## Cookie

**Cookiehaブラウザがパソコンのハードディスクに保存する小さなデータ**
Cookieとは、クライアント（ブラウザ）に保存される簡易なテキストファイルのこと。
サーバー（Rails）がクライアントに、一時的に情報を記録させるときに使用します。

httponlyオプション
httponlyは、HTTP通信でのみアクセスできるCookieを生成するためのオプションです。

このオプションを付けると、JavaScriptからのアクセスを完全に遮断することができ、サーバーサイドのRailsでしかアクセスできなくなります。
これにより、外部JavaScriptからのCookie盗聴を防ぎます。

- Cookieでも万全ではないことを理解しておく
Cookieへの保存は、外部からの攻撃を完全に遮断できるわけではありません。

JavaScriptで参照できるローカルストレージよりはマシなだけであって、Cookieのhttponlyオプションは、あくまで最低限のセキュリティだとお考えください。

**Cookieの法定タイムゾーンはGMT（グリニッジ標準時）と決められており、expiresはGMTで保存されます。**
**また、有効期限を判断するために使用されるタイムゾーンもGMTです。**
**GMTは日本時間マイナス9時間で、UTC（世界標準時）と一致します。**

## サブドメインでcookieを共有する

[参考URL](https://qiita.com/il-m-yamagishi/items/9aad5737c80d5bfd5eb8)

## クロスオリジン通信でのCookie共有設定

クロスオリジン通信でのCookie共有は双方に設定が必要。

**credentials（クレデンシャル）**
リクエストヘッダーのwithCredentials（ウィズ クレデンシャル）フラグをtrueにする。
withCredentialsは、クロスオリジンのクライアント資格情報を使用して、リクエストを行うことを許容するか否かを設定するフラグです。（デフォルトはfalse)

trueにすることで、
クロスオリジンリクエストの際に、Cookieを送信することができ、
また、クロスオリジンレスポンスのCookieを受け取ることができます。

## Session セッション

セッションはCookieを使って実現するのが一般的

## JWT

[JWT=ステートレス"から一歩踏み出すための考え方](https://zenn.dev/ritou/articles/4a5d6597a5f250)

---

ここからは書籍Webを支える技術を参考にする



## 3章 Webのアーキテクチャスタイル

![アーキテクチャスタイル](image/アーキテクチャスタイル.png)

実際のシステムは具体的なアーキテクチャを持っている。そのアーキテクチャを設計するときにただ闇雲に作っているのではなく**アーキテクチャ設計の指針、作法、流儀、つまりアーキテクチャスタイルを適用する**
システムのアーキテクチャを決定する際の羅針盤となるのがアーキテクチャスタイル

アーキテクチャ: ブラウザ/サーバ/プロキシ/HTTP/URI/HTML
↓
アーキテクチャスタイル((マクロ)アーキテクチャパターン): REST/MVC(Model-View-Controller)/パイプフィルタ/イベントシステム


## デザインパターン

デザインパターン(マイクロアーキテクチャパターン)といい、アーキテクチャスタイルよりも粒度の小さいクラスの設計様式を指す