# JWT(JSON Web Token) : ジョット
[参考URL](https://techblog.yahoo.co.jp/advent-calendar-2017/jwt/)
[JWTハンドブック(今度読む)](https://assets.ctfassets.net/2ntc334xpx65/5HColfm15cUhMmDQnupNzd/30d5913d94e79462043f6d8e3f557351/jwt-handbook-jp.pdf)


## JWTとは(JSON Web Token)

JWTは**JSONベースのデータを暗号化して作られる文字列で認証や認可のための仕組みとして利用される。**
属性情報（Claim: クレーム）をJSONデータ構造で表現したトークンの仕様。
JSONを使ったコンパクトでurl-safeなクレームの表現方法であり、OAuth2やOpenID Connectなんかで使われます。

## 通常のトークン認証との違い

通常のトークン形式の認証では**トークンの正当性を確認するためにサーバへの問い合わせが必要。**
JWTでは**公開鍵を利用してクライアント側でトークンの正当性を確認できる**という特徴がある。
トークンはオフラインで正当性が保証されるため、逆に一度発行したトークンが困難であるというデメリットも存在します。

また通常のトークンがそれ自体ではまったく意味を持たないケースがほとんどであるのに対し、JWTは**それ自体が情報を持つトークン。**
このためJWTの内部に個人情報などを含めることは推奨されない。

## 特徴

署名・暗号化でき、URL-safeであることが挙げられる

## JWT歴史

JWTでは
- **署名付きデータの場合はJWS**
- **暗号化する場合はJWE**
の仕様に基づき、JWTが利用されますが、**現状使われている多くのJWTが署名付きのものである**

---

## アクセストークンとしてJWTを利用することの利点
[わかりやすい](https://ritou.hatenablog.com/entry/20140927/1411811648)

JWTは単なるJSONのため、アクセストークンとして用いることにおりさまざまな情報を含めることができる。
それにより、認証サーバとアプリケーションサーバを分割しているようなアーキテクチャであれば、認証サーバの負荷を軽減することに寄与します。



## JWT構造

<ヘッダー>.<ペイロード>.<署名>

## JWTのClaimについて
[参考URL](https://kamichidu.github.io/post/2017/01/24-about-json-web-token/)

JWTで表現されるJSONオブジェクトはClaims Set（Claimの集合）と呼ばれます。 
ClaimとはJSONの`key, value`の一対を意味します。



## exp

- 期限を無期限にする
JWT内に存在する場合にのみ、`exp`フィールドを検証します。JWTにこのフィールドが含まれていない場合、トークンは無期限に有効とみなされます。

### ヘッダー

ヘッダーはJWTの署名検証を行うために必要な情報を格納するためのパートとなっている
文字列の形式としては、キー名と値のペアで表現されたJSONをBase64urlエンコードした文字列となる

Base64エンコードの場合は"+", "/", "="が含まれるが、**JWTはURIのクエリパラメーターなどに使用されることを想定しているため**
URL-safeに表現するためにBase64urlエンコードがされている。

```jsonc
// JWTをデコードする
// このヘッダーから署名アルゴリズムでJWTの検証を行う
{
  "typ": "JWT",
  "alg": "HS256"
}
```

### ペイロード

payloadに含める値をクレームと言う。
ペイロードはやり取りに必要な属性情報(Claim: クレーム)
ペイロードの内容はアプリケーションによっては異なるため、必須とされるものは存在しませんが、相互運用性のある属性情報については予約済みパラメーターとして提供されています。
ヘッダーと同様に、JSONをBase64urlエンコードした文字列なので、デコードが容易にできます。

```jsonc
{
  "admin": true,
  "name": "John Doe",
  "sub": "1234567890"
}
```

### 署名

署名パートは、エンコード済みヘッダー、ピリオド（"."）、エンコード済みペイロードを連結したものを入力値として"alg"の署名アルゴリズムで署名し、Base64urlエンコードすることにより作成されます。

`TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ`

↑の文字列を**ヘッダーで指定されたアルゴリズムで署名検証**することにより ID Tokenの正当性を評価できる。

----

## JWTの保存先

ローカルストレージはJSで簡単にアクセスできるためやめた方がいい。
他の部分

Cookieも検討に入るが、ローカルストレージよりはマシなだけ


---

## サーバ側のJWT取得方法

1. リクエストのヘッダーから取得する方法
2. クッキーに保存したトークンを取得するパターン

### 1について (リクエストヘッダー)

主に一時的に発行したトークンを取得する際に使用する
セキュリティを考慮してトークンの有効期限を短めに設定する必要がある

**一時的に発行するトークンを使用する場面**
- 会員登録時のメールアドレス認証時
- パスワードリセット時
- メールアドレス変更時

フロントからリクエストヘッダーに埋め込む

```js
export default ({ $axios }) => {
  $axios.onRequest((config) => {
    config.headers.common.Authorization = `Bearer ${<accessToken>}`
  })
}
```

## 2について(Cookie)

![cookieについて](image/jwt_cookie.png)

## JWT(JSON Web Token)

[JWTを使った今どきのSPAの認証について](https://tech.hicustomer.jp/posts/modern-authentication-in-hosting-spa/)

**JWTを用いることでパスワードなどの認証情報をDBに保存する必用がない**というメリットがある

2つのパーティー間で情報を安全に送信するための方法→『二者間で情報のやりとりを目的とした、JSONベースの形式について規定した標準仕様』

実態は、**JSONオブジェクトをエンコードした文字列でこの文字列をトークンと呼ぶ。**

**3つの文字列がピリオドで連結されている**
JWTが発行したトークンは、ドットによって3つにわかれている
それぞれ**Base64でエンコードされた文字列**となっている.
`<ヘッダ>.<ペイロード>.<署名>`

- ヘッダ(署名の検証に必用な情報)
ここにはトークンのタイプや、使用されている署名アルゴリズムの情報を持っています。

```js
// エンコード => デコード
eyJhbGciOiJIUzI1NiJ9.
=> { "alg": "HS256", "typ": "JWT" }
```

- ペイロード(やり取りに必用な情報。ユーザー情報など)
2番目の文字列をペイロードと呼び、任意の情報を指定することができる。
**基本的には、このペイロードをカスタマイズしてユーザー認証に必要な情報を埋め込む**

```js
// エンコード => デコード
eyJleHAiOjE2MDA1OTY0MzEsInN1YiI6MSwibmFtZSI6InVzZXIwIn0.
=> {"exp"=>1600596431, "sub"=>1, "name"=>"user0"}
```

expやsubなどのそれぞれの値をクレームと呼ぶ
**デフォルトで指定されている値を予約クレーム、使用者が任意に指定した値をパブリッククレームと呼ぶ**

- 署名(検証する内容): 署名には秘密鍵を使うため、これをも用いて検証を行うことができる。
3番目の文字列には署名情報がある。
**この署名は、トークンが変更されていないか確認するために使用される。**

```js
// エンコード => デコード
lXcwASyLX5GEsMvPYDVhe0ovJj631fUiC0q2ojK-yK0
=> HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
)
```

## sub(Subject)クレーム

JWTの主語となる主体の識別子で予約クレームのひとつ。
直訳すると「件名・主題」で、一般的にはオブジェクトを識別する一意性の値を指定します。
ユーザーテーブルで言うと、ユーザーIDのことです。
このクレームは任意で、{ user_id: 1 }と言ったペイロードでも問題ありません。
ただし、他アプリケーションとの衝突を避けるために予約クレームを使用することが推奨されています。

- 鍵の指定
トークンの発行には**署名時に使用する鍵が必要。**
この鍵が漏れると、誰でもトークンの発行と検証ができてしまうため非公開であるRailsのシークレットキーを使用する(Railsの場合)

発行手順

```sh
irb(main):001:0> payload = { sub: 1}
irb(main):002:0> secret_key = Rails.application.credentials.secret_key_base
irb(main):003:0> token = JWT.encode(payload, secret_key) # 暗号化し発行
irb(main):004:0> token
=> "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOjF9.0HBLImIKESioXrusu-yz4g53qpxrAahNyXRfgTQ5eJ0"
irb(main):005:0> JWT.decode(token, secret_key) # JWTをデコードする
=> [{"sub"=>1}, {"alg"=>"HS256"}]
```

## JWTのいいところ

1. JWTの最大のメリットは情報が改ざんできない
2. ユーザテーブルにトークンを保有するカラムを作成しなくてよくなる
この仕組みを認証に使えば、ユーザーテーブルにトークンを一時的に保有するカラムを作成しなくて良くなる。
3. トークン発行時に電子署名を付与することができるため、署名をした鍵を持つものしかトークンを検証することができない

>署名時に付けた鍵と同じ鍵を使って検証する署名アルゴリズムを「HS256」、
>秘密鍵と公開鍵のペアで検証する署名アルゴリズムを「RS256」

## JWTの注意点

トークンはエンコード（Base64）されているだけで暗号化はされていない。
トークンの中身は以下で見られてしまう。

[jwt.io](https://jwt.io/introduction/)

**漏れたらまずい個人情報（メールアドレスなど）はトークンへ埋め込まないようにする。**

## JWTの保存先

JWTの保存先には、**ローカルストレージがよく挙げられるがJavaScriptで簡単にアクセスできてしまう(XSS)**
認証に使用するJWTはログインメールアドレスとパスワードと同じ意味を持つため、**外部のJavaScriptからアクセスできない場所に保管することが望ましい。**
**そのためJWTをCookieｎ保存する。方法もある**

## JWTはCookieを使った認証の代わりにはならない

JWTの有効期間が切れた後に、再度ログイン画面を表示する必要がある。JWTが切れるたびにログイン情報を入力させるのは、Cookieを使用したステートフルな認証に比べてUXが劣る。

JWTは有効期間を長くすると危険。今回の用途だとJWTはc、HttpOnly cookiesのようにJSからアクセスできない領域に保存できないため、常に漏洩のリスクと戦うことになる。npmの最近のCVEを見る限り、Third partyのJSライブラリをすべて監査することは不可能。そのためあまり有効期限を長くできない。これはrefresh tokenの仕組みを使っても同じ。

## 認証トークンの歴史
[参考URL](https://www.okta.com/jp/identity-101/what-is-token-based-authentication/)


### JWTでトークンを管理する

**OpenID ConnectはIDトークンをやり取りする、これはJWTというトークンの形式になっている。**
JWTはユーザー認証において大切な概念なので、簡単に説明しておきますね。

JWTは『二者間で情報のやりとりを目的とした、JSONベースの形式について規定した標準仕様』
サーバー側でトークンが正しいかどうかをその場で検証できます。JWTを用いることで、パスワードなどの認証情報をデータベースに保存する必要がない、というメリットがあります。

### JWTによるアクセストークンをどう引き回すか

この認証結果として、**アクセストークン**が返されることになります。
以降は、このアクセストークンを用いて認証することになる(JWTで)

方法は２つある。

### 1. Authorizationヘッダ

このやり方は、**認証を行うために定義**されているAuthorizationヘッダーに**アクセストークン(JWT)を入れるやり方**たとえば次のような形式

`Authorization: Bearer <アクセストークン>`
このAuthorizationヘッダーは、**Basic認証やDigest認証で使われていた。**
その後RFC6750でBearerというスキームが策定されました。これは単一の文字列を認証情報として送信するのに適しています。

**1の特徴をまとめる**
- ステートレス。サーバー側にセッションストアがいらない
- ネイティブプラットフォームで扱いやすい
- Cookieが使用できない環境でも問題ない
**Authorizationヘッダーを用いるやり方は、OpenID Connect、パスワードのどちらの認証方法にも適しています**

### 2. Cookieヘッダー

このやり方は、CookieヘッダーにセッションIDを入れつつ、サーバ上でも保存しておくやり方
ユーザー認証を一度行ったら、以降はCookieヘッダーに含まれるセッションIDとサーバー側のセッションIDを照合してユーザーを識別します。

```sh
# サーバ側からクライアントにCookieのセットをリクエスト
Set-Cookie: SID=<セッションID>

# クライアントからサーバにリクエストを行うときにセット
Cookie: SID=<セッションID>
```

**２の特徴をまとめる**
- ステートフル。データベースなど外部のストレージからセッションを取得する必要がある
- サーバーにリクエストするたびに自動でCookieが送信される
- CSRF脆弱性への対策をする必要がある
- 異なるドメインに対して制約がつく（=CORS）

**APIは一般的にステートレスで行うため、Cookieヘッダーによる引き回しは実用的ではないといえます。**
このやり方はパスワード認証かつ、ネイティブアプリやSPAでない従来のWebアプリケーションに適していると思います。

### アクセストークンをどう保持するか

パスワードやOpenID Connectでユーザー認証を行うと、アクセストークンが発行されます。
これをヘッダーに乗せて認証します。つまり、クライアント側でアクセストークンを保持しておかなければなりません。

アクセストークンはどう保存すればいいのでしょうか。大きく次の4つがありますが、結論からいうと可能な限り『OS標準のストレージ』か『メモリ』に保持します：

### OS標準のストレージ iOSのKeyChain、AndroidのKeyStore

iOSのKeyChainやAndroidのKeyStoreなど、OSが標準で提供しているストレージを利用するやり方です。Auth0によるアクセストークンの保持についての記事でも、次のメモリとあわせて推奨されているやり方です。

### メモリ(JavaScriptの変数など)

[JWTを使った今どきのSPA認証について](https://tech.hicustomer.jp/posts/modern-authentication-in-hosting-spa/)

JavaScriptの変数などに格納し、CookieやlocalStorageには保存しないやり方です。スコープに気をつける必要はありますが、永続化しないため安全といえます。
**ただ、ページから離脱するとアクセストークンが消えてしまうので、ソフトウェアが要件を満たせる場合のみ採用できるやり方になります。**

### Cookie(WebブラウザのCookie)

これはWebブラウザのCookieを使うやり方ですね。Cookieを使うやり方にはいくつか問題があります。たとえばXSS脆弱性やCSRF脆弱性などです。
CookieにSecure属性やHttpOnly属性をつければ安全性はいくらか高まります。ただ、Authorizationヘッダーを用いる場合JavaScriptを用いることになるのでHttpOnly属性をつけられません。つまりXSS脆弱性が残ってしまいます。

### localStorage(Web Storage APIのlocalStorage)

Web Storage APIのlocalStorageを使うやり方です。これもCookieと同じくJavaScriptから操作可能なので、XSS脆弱性が残ります。また、localStorageには『HTML5のLocal Storageを使ってはいけない』で書かれているようないくつかの問題点もあります。

以上、いずれの場合もクライアントとサーバーのやり取りにHTTPSで通信するのは必須ですね。HTTPだと通信が見えてしまうので、アクセストークンが盗まれる可能性があります。

**また、CookieやlocalStorageを使う場合は有効期限を短くしてリスクを下げるなどの対策が必要だと思います。**

## アクセストークンとリフレッシュトークン