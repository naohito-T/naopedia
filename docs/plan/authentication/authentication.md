# Authentication

ユーザ認証周りの理解と設計についてまとめる

```sh
# 今後このユーザー認証周りをplantUMLで書く

```

[参考URL](https://applis.io/posts/how-to-authenticate-user)

## ユーザ認証の基本フロー

[参考URL(すばらしい)](https://applis.io/posts/how-to-authenticate-user)
[一番分かりやすい OAuth の説明](https://qiita.com/TakahikoKawasaki/items/e37caf50776e00e733be)

## ユビキタス

**リソースサーバ** : ユーザーのデータを管理するサーバ
**APIを守る仕組みのベストプラクティス** : アクセストークン(あらかじめクライアントアプリケーションに渡す)
**アクセストークンを発行する係** : 認可サーバ
※認可サーバにアクセストークンをくださいといい、渡すまでの流れを標準化したものがOAuth 2.0
**OAuthが明言していること** : アクセストークンを発行する仕組みであって**認証については定められていない。**また、**認証に必要な、ユーザー情報などの取得については決まっていない**

### 基本的なユーザー認証のフロー

1. クライアントからサーバに認証情報をおくる
2. サーバー上で認証情報を検証する
3. 認証情報が正しければ、クライアントにアクセストークンを送る(+必要に応じてセッションに記録する)


たとえばフォームにメールアドレスとパスワードを入力・送信し、入力内容が正しければサーバーからアクセストークン(これがAPIにアクセスできる認識だが？)
が渡される、というイメージ

### ユーザ認証を設計する上で決めるべきこと

| 順番  | 項目 | 選択肢 |
| --- | --- | --- |
| 1 |  認証方法をどうするか   |  パスワード認証 or OpenID Connect(OAuth認証のこと「厳密には違うが」) |
| 2 |  アクセストークンをどう管理するか   | JWT |
| 3 |  アクセストークンをどうStateに保持するか | Authorizationヘッダ, Cookieヘッダ |
| 4 |  アクセストークンをどう保持するか   | OS標準のストア?, メモリ, Cookie, localStorage |

## 1(認証方法をどうするかについて) 概要

まず、ユーザー認証の方法には、大きく次の二つがある。

|     | 認証方法  | 概要 |
| --- | --- | --- |
| 認証方法1  | パスワード認証 | IDとパスワードをサーバに送る |
| 認証方法2  | OpenID Connect | 外部のプロバイダ上で認証しアクセストークンをサーバに送る |

- 認証方法2について
OpenID Connectは、OAuth認証と聞くとなじみがある。
たとえばGoogleやTwitterなどのアカウントによる認証。
ただ、『OAuth認証』という言葉には語弊がある。

---

### パスワード認証とは

**パスワード認証にも大きく分けて2つ**ある

1. Basic認証やDigest認証
2. 独自の認証機構

※2の独自認証機構は例として、フォームからIDとパスワードをサーバに送って、**ユーザ基盤**をもとに認証を行う一般的なやり方。

この認証方法は**パスワードを平文で送ることになるため、仮にSSLで通信を暗号化していたとしてもログにかかれて流出につながる**

### ユーザ基盤とは

[クックパッドがユーザー基盤を再構築した話](https://techlife.cookpad.com/entry/2017/04/06/172601)

ユーザー登録のあり方が時勢にそぐわなくなっている
以下のは時代遅れ

メールアドレスとパスワードを使用し登録をする。

**なぜ？**
世のトレンドとしてEメール自体の利用シーンが減るに連れ、それを必須とするサービスまで使いづらいものになるという危機感がある。


---

## 2OpenID Connect(認証方法をどうするかについて)

### OpenID Connectについて

OAuthがアクセストークンを発行する仕組みのみのため、認証については定められていない。
認証に必用なユーザー情報などの取得については決まっていない。

このOAuthを拡張し、**ユーザー情報の取得についてなどを標準化したのがOpenID Connect**

>OpenID Connectは、『OAuth 2.0を使ってID連携をする際に、OAuth 2.0では標準化されていない機能で、かつID連携には共通して必要となる機能を標準化した』OAuth 2.0の拡張仕様の一つである。

## OpenID Connectによる認証のフロー

ようはアクセストークンをGoogle OAuthに取得しにいくフローのOpenID Connect版

1. クライアントがプロバイダへIDトークンを要求する
2. プロバイダがユーザー(クライアント）にIDトークンの発行可否を聞く。あわせて認証を行う
3. ユーザー(クライアント）がプロバイダに発行可否と、発行する場合に認証情報を送る
4. プロバイダがクライアントにIDトークンを発行する

>この1と4のやりとりを標準化したのがOpenID Connectです。OAuthが『アクセストークンを発行する仕組み』なのに対して、**OpenID Connectはこれを拡張して『IDトークンを発行する仕組み』**と考えるとわかりやすいかもしれません。
>『Googleなどのアカウント認証を使う』=『OpenID Connectを使う』という認識がもてればいいのかな、と思います。

**Googleの認証方法はOpenID Connectではない**
OpenID Connectについて書きましたが、実際のところGoogleやTwitterの認証はOpenID Connectではありません。GoogleはOpenID Connectの仕様に準拠しつつ、OAuth 2.0を採用しています。TwitterはOAuth 1.0aという仕様で、OpenID Connectには準拠していません。

いずれにしてもOAuthをベースにした認証を行なっていますが、ここではわかりやすさのためにOpenID Connectという用語に統一して説明しています。

### JWTでトークンを管理する

**OpenID ConnectはIDトークンをやり取りする、これはJWTというトークンの形式になっている。**
JWTはユーザー認証において大切な概念なので、簡単に説明しておきますね。

JWTは『二者間で情報のやりとりを目的とした、JSONベースの形式について規定した標準仕様』
サーバー側でトークンが正しいかどうかをその場で検証できます。JWTを用いることで、パスワードなどの認証情報をデータベースに保存する必要がない、というメリットがあります。

### JWTによるアクセストークンをどう引き回すか

この認証結果として、アクセストークンが返されることになります。
以降は、このアクセストークンを用いて認証することになる(JWTで)

方法は２つある。

### 1. Authorizationヘッダ

このやり方は、認証を行うために定義されているAuthorizationヘッダーに**アクセストークン(JWT)を入れるやり方**たとえば次のような形式

`Authorization: Bearer <アクセストークン>`
このAuthorizationヘッダーは、**Basic認証やDigest認証で使われていた。**
その後RFC6750でBearerというスキームが策定されました。これは単一の文字列を認証情報として送信するのに適しています。

**1の特徴をまとめる**
- ステートレス。サーバー側にセッションストアがいらない
- ネイティブプラットフォームで扱いやすい
- Cookieが使用できない環境でも問題ない

**Authorizationヘッダーを用いるやり方は、OpenID Connect、パスワードのどちらの認証方法にも適しています**

### 2. Cookieヘッダー
このやり方は、CookieヘッダーにセッションIDを入れつつ、サーバ上でも保存しておくやり方
ユーザー認証を一度行ったら、以降はCookieヘッダーに含まれるセッションIDとサーバー側のセッションIDを照合してユーザーを識別します。

```sh
# サーバ側からクライアントにCookieのセットをリクエスト
Set-Cookie: SID=<セッションID>

# クライアントからサーバにリクエストを行うときにセット
Cookie: SID=<セッションID>
```

**２の特徴をまとめる**
- ステートフル。データベースなど外部のストレージからセッションを取得する必要がある
- サーバーにリクエストするたびに自動でCookieが送信される
- CSRF脆弱性への対策をする必要がある
- 異なるドメインに対して制約がつく（=CORS）

**APIは一般的にステートレスで行うため、Cookieヘッダーによる引き回しは実用的ではないといえます。**
このやり方はパスワード認証かつ、ネイティブアプリやSPAでない従来のWebアプリケーションに適していると思います。

### アクセストークンをどう保持するか

パスワードやOpenID Connectでユーザー認証を行うと、アクセストークンが発行されます。
これをヘッダーに乗せて認証します。つまり、クライアント側でアクセストークンを保持しておかなければなりません。

アクセストークンはどう保存すればいいのでしょうか。大きく次の4つがありますが、結論からいうと可能な限り『OS標準のストレージ』か『メモリ』に保持します：

### OS標準のストレージ	iOSのKeyChain、AndroidのKeyStore

iOSのKeyChainやAndroidのKeyStoreなど、OSが標準で提供しているストレージを利用するやり方です。Auth0によるアクセストークンの保持についての記事でも、次のメモリとあわせて推奨されているやり方です。

### メモリ(JavaScriptの変数など)

JavaScriptの変数などに格納し、CookieやlocalStorageには保存しないやり方です。スコープに気をつける必要はありますが、永続化しないため安全といえます。
**ただ、ページから離脱するとアクセストークンが消えてしまうので、ソフトウェアが要件を満たせる場合のみ採用できるやり方になります。**

### Cookie(WebブラウザのCookie)

これはWebブラウザのCookieを使うやり方ですね。Cookieを使うやり方にはいくつか問題があります。たとえばXSS脆弱性やCSRF脆弱性などです。
CookieにSecure属性やHttpOnly属性をつければ安全性はいくらか高まります。ただ、Authorizationヘッダーを用いる場合JavaScriptを用いることになるのでHttpOnly属性をつけられません。つまりXSS脆弱性が残ってしまいます。

### localStorage(Web Storage APIのlocalStorage)

Web Storage APIのlocalStorageを使うやり方です。これもCookieと同じくJavaScriptから操作可能なので、XSS脆弱性が残ります。また、localStorageには『HTML5のLocal Storageを使ってはいけない』で書かれているようないくつかの問題点もあります。

以上、いずれの場合もクライアントとサーバーのやり取りにHTTPSで通信するのは必須ですね。HTTPだと通信が見えてしまうので、アクセストークンが盗まれる可能性があります。

**また、CookieやlocalStorageを使う場合は有効期限を短くしてリスクを下げるなどの対策が必要だと思います。**
