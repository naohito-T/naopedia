# browser

ブラウザの仕組み

[参考URL](https://zenn.dev/silverbirder/articles/e10295948e17ca)

## ブラウザにデータを保存する他の技術

|         | sessionStorage | localStorage | cookie |
| ------- | -------------- | ------------ | ------ |
| データ保存期間 | ウインドウ・タブを閉じるまで | 永続的 | 指定できる  |
| 保存容量 | 5~10MB | 5~10MB | 最大4KB |
| 別ウィンドウ/別タブからのアクセス | 不可 |可 | 可 |

## sessionStorage

sessionStorageはブラウザに保存するタイプ。
診断コンテンツなど、ページを閲覧している間だけ一時的にデータを保存しておきたい時など使用する。

- **ブラウザを閉じるとデータがクリアされる。**
- 同じタブ内の別ページはデータが保持される
- 別タブはデータが保持されない。
- 別ウィンドウにはデータは渡せない。

## localStorage

localStorageはWebStorageのひとつで、ユーザのPCに保存するタイプ。


localStorageやcookieは反対にセッションが途切れてもデータを残しておけるので、
たとえばIDやパスワードを保存して簡単にログインできる仕組みや、ECサイトでショッピングカートに商品のデータを保存する時などに使われています。

## cookie(クッキー)
[参考URL](https://www.kwbtblog.com/entry/2019/04/20/005423)
[参考URL](https://www.ecbeing.net/contents/detail/235)

**cookieが必要な前提**
HTTP通信の問題点
HTTP通信は1回1回の単発の通信なので、接続を維持し続けることができない。
HTTP通信はユーザー識別の仕組みがないので**どのユーザーからの接続**かを判別することができない。
なので、一連のHTTP通信で、ユーザー接続を維持し続けるには、何かしらの仕組みを実装する必要がある

解決方法
ユーザー認証完了後、サーバー側でユーザー識別子を発行する。
ブラウザへのレスポンスで識別子を送り次回以降ブラウザからサーバーへアクセスする際に、毎回その識別子をサーバーに送ることにより、サーバー側でどのユーザーからのアクセスかがわかるようにする。
そして、その識別子のやり取り方法の1つとして、クッキーを用いる方法がある。

## cookie属性



### cookieの種類

クッキーには2種類ある

- セッションクッキー
セッションクッキーは、Webサイトにアクセスしている間、ブラウザに一時的に作成され、ユーザーがサイトを離れると、セッションクッキーは削除されます。

- 永続クッキー
永続クッキーはユーザーがブラウザを閉じても削除されず、そのクッキーを作成したWebサイトにアクセスすると再度アクティブになります。永続クッキーは、Cookieのファイル内で設定された期間、ブラウザに残ります。

## session(セッション)

- セッションIDの**生成方法はHTTPの仕様として定まっていない。**サーバー側の実装に依存する
- セッションはWebサーバ側で保持する（セッション情報はDBやファイルなどで管理・保持する）

ブラウザ側ではCookie（クッキー）にセッション情報が保存されます。Cookie以外の方法もありますが、現在ではCookieを利用するのが主流です。
またCookieに保存するセッション情報は詳しい個人情報などではなく、次項から説明するセッション管理で使用するセッションIDだけ保存します。
そのためクライアント側ではセッションIDしか見えないため、万が一改ざんされても大きな影響はありません。


セッションID生成方法
- 
各プログラム言語にはメジャーなセッションライブラリがあり、セッションID生成には、それらを使うことが多い
それらのライブラリの多くのデフォルトの実装は、セッションIDとしてユニークで推測しずらい値を生成し、それをキーとして「ユーザーID」などのユーザーデータを紐付けて、ローカルファイルやメモリ上にキーバリューデータとして保存しておく
そして、ブラウザーからアクセスがあった場合は、クッキーからセッションIDを読み取り、セッションIDをキーに、キーバリューデータから該当するユーザーデータを復元する
キーバリューデータをサーバーのローカルファイルやメモリに保存するため、サーバーを複数設置して負荷分散させた場合、接続毎に接続先のサーバーが変わってしまうので、セッションが維持できなくなってしまう
なので、どのサーバーにアクセスしても適切なユーザーデータが復元できるように、キーバリューデータをローカルではなく、データベースに格納するようにすることも多い

### Expressでのセッション管理

Expressには、以下の2つのセッションモジュールがある
- cookie-session
- express-session
cookie-sessionはCookieにセッションデータを保存するミドルウェアです。
express-sessionはCookieにセッションIDのみを保存して、セッションデータは別のストレージに保存するミドルウェアです

## クッキー(Cookie)とセッションの違い

小括として、クッキーとセッションの違いをまとめておきましょう。
クッキーもセッションも情報を保存するために使用されることには違いがありません。
違いとしては保存場所が挙げられます。クッキーはクライアント側のマシン（主にブラウザ）にのみ保存され、セッションはブラウザだけでなく、サーバーにも情報が保存されます。
また、保存の期間にも大きな違いがあり、セッションはユーザーがブラウザを閉じるか、サイトを離れると情報が削除されます。一方、クッキーには永続クッキーがあり、情報を保持し続けます。
さらに、大きなポイントとしてはセッションは無効にできませんが、クッキーは無効にすることができる。

## Set-Cookie
[参考URL](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Set-Cookie)

Set-CookieはHTTPのレスポンスヘッダーで、サーバーからユーザーエージェントへクッキーを送信するために使用され、ユーザーエージェントはそれを後でサーバーに送り返すことができます。
複数のクッキーを送信するには、複数のSet-Cookieヘッダーを同じレスポンスで送信してください。


## SameSite

クロスサイトな状況でクッキーを発行させたい場合（埋め込みコンテンツなど）は、SameSite属性にNoneという値をセットする。
これで、クロスサイトでもクッキーが発行されます。そして警告にもあったように、この場合は必ずSecure属性もつけましょう。つまり今後、httpでクロスサイトなクッキーを発行してはいけないということです。

SameSiteには3つの設定を行うことが可能です。
None、Lax、Strictの3つとなります。
これはセキュリティレベルの高さの指定となり

- None（なし）
- Lax（緩い）
- Strict（厳しい）

上記の順番でセキュア（CSRF）に対するセキュリティレベルを示している。
仕様が変更にある前まではSameSiteを指定していない場合、ブラウザ側ではNone（なし）として判断してWebサイトからのCookieの利用を許可しておりましたが、今回のGoogle Chrome 80からはSameSiteを指定しない場合、Lax（緩い）として取り扱う形となりました。