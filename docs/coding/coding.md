# コーディング(program)

[新人プログラマに知ってもらいたいメソッドを読みやすくするいくつかの原則](https://qiita.com/hirokidaichi/items/c9a76191216f3cc6c4b2)
[プログラミング英語検定(これみれば変数名とか付けられる)](https://progeigo.org/learning/essential-words-600-plus/)

## コーディング速度をあげるコツ

コーディング速度を上げる一番の考え方は**迷いをなくすこと。**

## 俯瞰してみる力をつける(構造化)

たとえば
TSとして関数側が

```ts
interface CarvingComponentType {
  [k: string]: CarvingComponentReturnType;
}

const carvingType: CarvingComponentType = {
  // card repeating or cancel or failed = 要は既に加入している
  canPayment: { register: true, newLicense: false, canNotNewLicense: false, subscription: true },
  // card cancel
  undoPayment: { register: false, newLicense: false, canNotNewLicense: false, subscription: true },
  // newLicense
  newPayment: { register: false, newLicense: true, canNotNewLicense: false, subscription: false },
  // konbini
  konbiniInComplete: { register: false, newLicense: false, canNotNewLicense: false, subscription: true },
  // まったく通らない
  none: { register: true, newLicense: false, canNotNewLicense: false, subscription: true },
};

// 最終的にここを出力したい場合
{ register: true, newLicense: false, canNotNewLicense: false, subscription: true }

// 型定義は以下とし関数にセットし、受け取る側にもセットする
export interface CarvingComponentReturnType {
  register: boolean;
  newLicense: boolean;
  canNotNewLicense: boolean;
  subscription: boolean;
}
const carvingComponent = (
  license: License | null,
  userLicenses: UserLicense[] | null,
  orders: Order[],
): CarvingComponentReturnType => {}

// 受け取る側はこちらで定義ができると
const { carvingComponent } = useCarvingComponent();
```

## マジックナンバーをやめる

別の人がコードを見たときに何の数字かわからなくなる。
また、変数として持っておくことで変更が用意。メンテナンス性が上がる
そしてコード内の変更ではなくなるためテストが不要となる（これは言い回しでどうにかなりそう。ロジックは変更していませんなど変数を変更しただけだよと）

文字列でもマジックナンバーと同じように変数で持っておく
**値が変わったらぶっ壊れる**とかは変数で管理するべき。
また、ここで念頭にconfigとして別ファイルに責務を与えられないか考える。

## 正規表現でvscodeを検索する

正規表現を普段から使えるようにするための特訓として、vscodeの検索で使う。
ゲームのランタイムで正規表現を使わないとのこと（負荷が高いパターンなどあるため）

## DB 検索は 1 回で終わらせる。

DBにアクセスする部分で、一度の検索で終わらせるべき。処理が重いため
ただ副問い合わせなどをするとパフォーマンスはどちらが上なのかは知りたい

## 関数を作るのも、クラスを作るのも関心の分離を考えるべき

アプリケーションを3層に分けたとき（プレゼンテーション・ビジネスロジック・データアクセス）をベースに考えるとわかりやすい
ビジネスロジックをデータアクセスと切り離すというのは保存先がファイルだろうと、RDBだろうとドキュメントDBだろうと、保存ができるようにする。

ようは、ビジネスロジックは限定してはいけない（要は保存をかける時にはバリデーションや整形などすべてを気にしなくて良くする）

## applicationのレイヤーでパラメーターについて考えるのは良くないので、

status: TicketStatus[]
にして、
handler側でパースしてしまうのがいいかと思います！
バリデーションはなるべく上の層でしてしまうのがいい。
→なるべく早めにバリデーションへかけてしまうことでサーバの負荷も下がるため

## コードは今必要なものだけをかく

汎用性よりも単純性を考える。汎用性のもたらす再利用性や拡張性よりも**まずは使えることに価値を置く**
このパラメーター将来必要だろうとするよりも、今必要な機能の作成に時間をさく

## 新規の関数を作成するとき、共通処理がないか探す

関数の中で呼び出している処理が、他の関数でも同様の処理がある場合は二重管理となる。
そのため共通の処理として切り出せないか模索する

## 新規のクラスを作成するとき、共通のプロパティ・メソッドがあるのであればそれを base として切り出して抽象クラスやインターフェイスなどで切り出すことができないか考える

新規のクラスを作成するとき、共通のプロパティ・メソッドがあるのであればそれをbaseとして切り出して抽象クラスとして作成し、違うクラスを2つ作る。

## 参考演算子を使用してもより単純な選択肢が存在しているかもと考える

[参考URL](https://eslint.org/docs/rules/no-unneeded-ternary)

## メモ化を考える

メモ化はNextの<Script>タグがわかりやすい
[参考URL](https://zenn.dev/aiji42/articles/9a6ab12ab5f6e6)

### メモ化とは

メモ化とは同じ結果を返す処理について、初回のみ処理を実行記録しておき値が必要になった2回目以降は、**前回の処理結果を計算することなく**呼び出し値を得られるようにすること。

イベントハンドラーのようなcallback関数をメモ化し、不要に生成される関数インスタンスの作成を抑制、再描画を減らすことにより、都度計算しなくて良くなることからパフォーマンスを向上が期待できる

**わかりやすく**
関数はオブジェクトなのでプロパティを持てる。
そのプロパティにその関数の結果を格納しておけば、毎回計算しなくても値として格納しているものを読み込むだけのため速度が速くなるよね。ということ。

[メモ化参考 JS](https://qiita.com/syakegon/items/b9ef4c4c91bfd607c771)

---

これはTBD（To Be Determined）: 未定、未確定

- コードの省略ができるか考える（ファイル量を減らす目的）
※しかし極端な省略はチームによっては受け入れられない。

- ペラ1でコードを記載しているのであれば、envなどに定数は分けるべき。またconfigファイルなどに分けれるのか検討する。

- 値が返ってく前提で書いているのがいけない(常にundefained)が返ってくる or nullの可能性を示唆するべき

- 最近は文字列連結の中で変数確認する人はいなくなった(これは必要に応じてって感じ)

## 後で別ファイルに

## 抽象クラスとは

抽象クラスを継承したサブクラスは、抽象クラスにある抽象メソッドのオーバーライド必須
サブクラスでコンストラクタを記述しなければならない
直接インスタンス化できない
多重継承はできない

>象クラスを実装するメリットは、抽象クラスの特徴１に書いた、"抽象クラスを継承したサブクラスは、抽象クラスにある抽象メソッドを必ずオーバーライドしなければならない"です。
複数人で開発を行う場合に実装レベルのルールを作れる！です。

## 抽象クラスとインターフェースの違い

言語によるが、抽象クラスの多重継承を禁止していることが多い。
上記を踏まえると、抽象クラスは結合度が高くなる(実装するべきmethodなども多い)
その点、interfaceは実装の責任を課す部分もあるが、多重継承も可能のためファイル分割も可能となる。


## メモ化とは

メモ化とは同じ結果を返す処理について、初回のみ処理を実行記録しておき、値が必要となった2回目以降は前回の処理結果を計算することなく呼び出し値を得られるようにすること。

## 分岐アンチパターン

[参考URL](https://qiita.com/pakkun/items/9bef9132f168ba0befd7)

大事なこと
- 否定の否定は回避する(変数名の代入先と代入部分に着目しろ)
- 基本的に変数名は肯定で記述しよう


```php
// アンチパターン
$delete_off = false;
// 両方、否定の否定になっている

// 対策
$delete_on = true

```


## コーディング規約

コーディング規約は多数のプログラマが参加するプロジェクトにおいて、プログラミング品質を均等にするために定める文書

メンバーのスキルが高い場合は、コーディング規約はできるだけ薄い方が良い。高スキル者に色々規約を守らせようとすると生産性が大幅に落ちてしまい高スキル者を集めた意味がない。

## 再生 vs 再認

認知心理学では、2つの記憶のモード、再生と再認を考える。

- 再生
再生は過去の記憶を何もインプットがなくても思い出せる状態。
- 再認
これは体験したことがありますか？と問われてたらああ、これは体験したことがあると思い出せる状態。

## 再生するには？

再生をするには完全に完全に記憶しきっている状態にならないとダメ。
慣れている人は、数多くのパターンを記憶しておりそれを再生することでコードが書ける。他の人のコードを見たときにも過去のパターンと照らし合わせてよりよいコードパターンを思いついたりする。

**再認の方が難易度は低い。**ドキュメント、サンプルコード、ネットで調べた情報などを辿りながら、それを組み合わせて実装します。時間もかかりますし、**検索で出てこないパターンだとパフォーマンスが落ちる。**
ですが、なんどもなんどもコードを見て繰り返し再認していくと、再生でコードが書けるようになります。このドキュメントは再認の効率アップがゴールです。

とはいえ、必ずしも全員が再生レベルになる必要はありません。たとえGoに慣れていても、普段使わないパッケージ（cryptoパッケージの暗号化とか）を使う場合は再認で（サンプルのコピペで）コードを書くことになるでしょう。上級者でも、自分用のスニペット集を作ることで、記憶の能力の節約しつつパフォーマンスは落とさないということをしますね。


## コーディングを書き始める前に念頭においておくもの

1. 仕様は確認したか？ビジネス要件 & サイトの機能、役割がわかっていないと全体像を見通せない。
そのため全体像を把握していることを考える。
2. コードを書き始める前にコメントでその処理をやることを考える。


## Railsの哲学から汎用性のあるものを抽出


同じことを繰り返すな（Don't Repeat Yourself: DRY）: DRYはソフトウェア開発上の原則であり、「システムを構成する知識のあらゆる部品は、常に単一であり、明確であり、信頼できる形で表現されていなければならない」というものです。同じコードを繰り返し書くことを徹底的に避けることで、コードが保守しやすくなり、容易に拡張できるようになり、そして何よりバグを減らすことができます。

設定より規約が優先（Convention Over Configuration）: Railsでは、Webアプリケーションで行われるさまざまなことを実現するための最善の方法を明確に思い描いており、Webアプリケーションの各種設定についても従来の経験や慣習を元に、それらのデフォルト値を定めています。このようにある種独断でデフォルト値が決まっているおかげで、開発者の意見をすべて取り入れようとした自由過ぎるWebアプリケーションのように、開発者が延々と設定ファイルを設定して回らずに済みます。

## 論理演算を考えろ(ドモルガンの法則)

```js
!(P || Q) == !P && !Q
!(P && Q) == !P || !Q

const hasUserLicense = !(isSubscriptionFailed.value || isWaitingKonbiniCharge.value);
```
[ドミルガンの法則](https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%BB%E3%83%A2%E3%83%AB%E3%82%AC%E3%83%B3%E3%81%AE%E6%B3%95%E5%89%87)

## switch 文

スタイルシート系は抜いて、
網羅できていないものはいい。

switch文では文字を返してはいけない返すのは変数
なぜなら変数を返すだけなら変更の影響は少ないから

そして上司にはこう言える
documentを変えたダケのためテストは入りません。
プログラムの動作は変更がないためテストは不要だろう？という話

## if文を減らすには


## 真偽値

[参考URL](https://qiita.com/yskszk/items/5a7f99c974773f03a82a)


## オーバーロード

**メリット**
オーバーロードを使う場合、同じような機能で引数にint型とdouble型がある場合でもメソッド名は同じ。
そのため、**メソッドを使う人は引数の型を気にする必要がない**
このようにオーバーロードを使うことで、メソッドを使う人が "引数の型を意識せずに使える"というメリットがありま
す。
オーバーロードが使われている身近な例のひとつに「System.out.println()」があります。printlnメソッドは、int, double, Stringなど引数の型が違っても同じメソッド名で使用できますよね。
このように、オーバーロードすれば引数によってメソッドの名前を少しずつ変更する必要がなく、メソッド名を覚える必要もなくなる、など様々なメリットがあります。

**デメリット**
オーバーロードの使い方によってはデメリットも存在します。
たくさんオーバーロードしすぎた場合、プログラムの理解がしにくく管理が難しくなってしまいます。またしっかりと設計しないと、同じ名前でもばらばらの処理を行うメソッドが生まれてしまったりして、混乱を招いてしまうこともあるでしょう。
オーバーロードは便利ですが、何にでも使えばいいわけではありません。必要なところを見極めて使用しましょう。

## 配列から重複要素を取り除く

「Setに渡した値は重複しない」という特性を使って、配列から値が重複する要素を取り除く処理に応用できる。

## エラーハンドリング

エラーハンドリングとして、その言語で標準に設定されているものや
```ts
const hello = () => {
  throw new Error();
}
```

その言語のErrorインターフェイスを満たした独自の型を定義する方法がある。

## 世界対応なのか日本対応なのか

[タイムゾーンの意識](https://blog.studysapuri.jp/entry/2016/12/05/090000)


```
Time.zone = 'UTC'
Time.zone.now
# => Thu, 04 Feb 2016 10:00:00 UTC +00:00

Time.use_zone('Asia/Tokyo') { Time.zone.now }
# => Thu, 04 Feb 2016 19:00:00 JST +09:00
```

## エラーメッセージは見ろ

しっかりみて検索する力を、GitHubのissueとか探せ 