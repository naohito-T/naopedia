# Cookie
[参考URL](https://www.kwbtblog.com/entry/2019/04/20/005423)
[参考URL](https://www.ecbeing.net/contents/detail/235)

**Cookieはブラウザがパソコンのハードディスクに保存する小さなデータ**
Cookieとは、クライアント（ブラウザ）に保存される簡易なテキストファイルのこと。
サーバー（Rails）が**クライアントに一時的に情報を記録させるときに使用する**

## cookieが必要な理由

HTTP通信の問題点
HTTP通信は1回1回の単発の通信なので、接続を維持し続けることができない。
HTTP通信はユーザー識別の仕組みがないので**どのユーザーからの接続**かを判別することができない。
なので、一連のHTTP通信で、ユーザー接続を維持し続けるには、何かしらの仕組みを実装する必要がある

解決方法
ユーザー認証完了後、サーバー側でユーザー識別子を発行する。
ブラウザへのレスポンスで識別子を送り次回以降ブラウザからサーバーへアクセスする際に、毎回その識別子をサーバーに送ることにより、サーバー側でどのユーザーからのアクセスかがわかるようにする。
そして、その識別子のやり取り方法の1つとして、クッキーを用いる方法がある。

httponlyオプション
httponlyは、HTTP通信でのみアクセスできるCookieを生成するためのオプションです。

このオプションを付けると、JavaScriptからのアクセスを完全に遮断することができ、サーバーサイドのRailsでしかアクセスできなくなります。
これにより、外部JavaScriptからのCookie盗聴を防ぎます。

- Cookieでも万全ではないことを理解しておく
Cookieへの保存は、外部からの攻撃を完全に遮断できるわけではありません。

JavaScriptで参照できるローカルストレージよりはマシなだけであって、Cookieのhttponlyオプションは、あくまで最低限のセキュリティだとお考えください。

### cookieの種類

クッキーには2種類ある
- セッションクッキー（sessionと共に利用する）
セッションクッキーは、Webサイトにアクセスしている間、ブラウザに一時的に作成され、ユーザーがサイトを離れると、セッションクッキーは削除される。
- 永続クッキー
永続クッキーはユーザーがブラウザを閉じても削除されず、そのクッキーを作成したWebサイトにアクセスすると再度アクティブになります。永続クッキーは、Cookieのファイル内で設定された期間、ブラウザに残ります。

## Cookie expires時間

**Cookieの法定タイムゾーンはGMT（グリニッジ標準時）と決められており、expiresはGMTで保存されます。**
**また、有効期限を判断するために使用されるタイムゾーンもGMTです。**
**GMTは日本時間マイナス9時間で、UTC（世界標準時）と一致します。**

## サブドメインでcookieを共有する

[参考URL](https://qiita.com/il-m-yamagishi/items/9aad5737c80d5bfd5eb8)

## クロスオリジン通信でのCookie共有設定

クロスオリジン通信でのCookie共有は双方に設定が必要。

**credentials（クレデンシャル）**
リクエストヘッダーのwithCredentials（ウィズ クレデンシャル）フラグをtrueにする。
withCredentialsは、クロスオリジンのクライアント資格情報を使用して、リクエストを行うことを許容するか否かを設定するフラグです。（デフォルトはfalse)

trueにすることで、
クロスオリジンリクエストの際に、Cookieを送信することができ、クロスオリジンレスポンスのCookieを受け取ることができます。

## クッキー(Cookie)とセッションの違い

小括として、クッキーとセッションの違いをまとめておきましょう。
クッキーもセッションも情報を保存するために使用されることには違いがありません。
違いとしては保存場所が挙げられます。クッキーはクライアント側のマシン（主にブラウザ）にのみ保存され、セッションはブラウザだけでなく、サーバーにも情報が保存されます。
また、保存の期間にも大きな違いがあり、セッションはユーザーがブラウザを閉じるか、サイトを離れると情報が削除されます。一方、クッキーには永続クッキーがあり、情報を保持し続けます。
さらに、大きなポイントとしてはセッションは無効にできませんが、クッキーは無効にすることができる。

## cookie属性

>ウェブサーバーとウェブブラウザとの間でやりとりできる小さなデータとして「クッキー (Cookies)」というものがあります。このクッキーは属性を持たせることができるのですが、その中にはセキュリティを高めるための属性がいくつかあります。

## Set-Cookie
[参考URL](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Set-Cookie)

Set-CookieはHTTPのレスポンスヘッダーで、サーバーからユーザーエージェントへクッキーを送信するために使用され、ユーザーエージェントはそれを後でサーバーに送り返すことができます。
複数のクッキーを送信するには、複数のSet-Cookieヘッダーを同じレスポンスで送信してください。

## Secure属性

>Secure 属性がついたクッキーは HTTPS プロトコル上の暗号化されたリクエストでのみサーバーに送信され、安全でない HTTP では決して送信されない

## SameSite
[参考URL](https://www.ecbeing.net/contents/detail/235)
[Chrome で SameSite=None に関する Cookieについての警告が表示される](https://laboradian.com/warning-about-cookie-samesite-none/)

Chromeがデフォルトでクッキーを`SameSite = Lax`として扱うようになる

クロスサイトな状況でクッキーを発行させたい場合（埋め込みコンテンツなど）は、SameSite属性にNoneという値をセットする。
これで、クロスサイトでもクッキーが発行されます。そして警告にもあったように、この場合は必ずSecure属性もつける
つまり今後、httpでクロスサイトなクッキーを発行してはいけないということです。

SameSiteには3つの設定を行うことが可能です。
None、Lax、Strictの3つとなります。
これはセキュリティレベルの高さの指定となり

- None（なし）
- Lax（緩い）
- Strict（厳しい）

上記の順番でセキュア（CSRF）に対するセキュリティレベルを示している。
仕様が変更にある前まではSameSiteを指定していない場合、ブラウザ側ではNone（なし）として判断してWebサイトからのCookieの利用を許可しておりましたが、今回のGoogle Chrome 80からはSameSiteを指定しない場合、Lax（緩い）として取り扱う形となりました。

## SameSiteなどの回避方法

Chrome84からCookieの属性であるSameSiteのデフォルト値がNoneからLax変更されたことにより、異なるオリジン間でCookieが受け取れなくなっていた。
明示的にSameSite=Noneを設定することでCookieを受け取れるようにはなるが、そうすると次はCookieの属性であるSecureも必須となる。

対応内容
>ローカル環境をSSLする必要があるのかと思ったらdevserverのproxyオプションで解決した。
>同一オリジン扱いになるのでCORS問題も解決できそう。

つまりproxyを立てて通信を行う（local）、devでも行う必要があるのか気になる。

[Next Http Proxy Middlewareで Next.js × Rust間のリクエストをproxyする](https://sayu-do.com/2022-2-3/196/)
