# Programing 言語

言語について記載していくフォルダー
下にこのディレクトリの各ファイルへのリンクを入れても良いかも

## Programing 計算量を求める
[参考URL](https://qiita.com/cotrpepe/items/1f4c38cc9d3e3a5f5e9c)

>特に Node.js サーバーをシングルスレッドで運用する場合、 O(n^2) のような計算量を要求するような処理は、 たった1つのリクエストが他のリクエストを阻害してしまうので致命的な不具合となりえます。

---

## Programing 言語種類

コンパイルされて実行できる状態になったプログラムのことを実行形式と呼ぶ

### スクリプト言語(scripting language):軽量言語 または LL(Lightweight Language)

[参考URL](https://e-words.jp/w/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E8%A8%80%E8%AA%9E.html)

一般的に軽量言語（LL）ではメモリ管理のコストなどに注意してコードを構成しなければパフォーマンスが極端に悪くなることがある。
※Goは細部を気にせずコードを書いても、比較的パフォーマンスを引き出しやすい傾向がある。

### マクロ言語

**ソフトウェアの動作の自動化**などを行なうプログラムを記述する言語はマクロ言語と呼ばれることがある。

## 静的型付けのメリット

- 型安全性
- ドキュメント化と入力保管
静的型付けの言語では型の情報がソースコードに書かれる。この情報はDXをかなり助ける。

---

## フレームワーク ベンチマーク
[元のURL](https://gigazine.net/news/20200804-web-framework-benchmark/)
[Web Framework Benchmarks](https://www.techempower.com/benchmarks/#section=data-r19&hw=ph&test=fortune)

## 新規のプロジェクトに入る時の心構え

全体がわかっていないとコードを書くことが絶対わからない。
必ず新規プロジェクトに入った際には必ず仕様やドキュメントをしっかりみること。

## プログラムを書く前に考えること

書きながらロジックを構成していくのは上級者。
そうなるべきだが、まずは紙でも良いのでロジックを考える。
ロジックが完成してから書く癖を。
同じことを繰り返すな

## 変数/メソッド名 コメント

原則使わなくて済む方が良い。

- コメントなしで意味が伝わる命名をする
- 関数の引数は命名だけではなく、TypeScriptの情報量を増やす

## メソッド名

**メソッド名の場合は動詞や助動詞を用いて命名する**

[参考URL](https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6)

このパターンで適宜考えないといけない

- 真偽値を返すメソッド
- 必要に応じてしか実行されない処理をするメソッド
- 非同期処理に関連するメソッド
- コールバックメソッド
- コレクションの操作に関するメソッド
- 状態に関するメソッド
- オブジェクトのライフサイクルを扱うメソッド
- データに関するメソッド


## クラス名

[参考URL](https://qiita.com/KeithYokoma/items/ee21fec6a3ebb5d1e9a8)

**クラス名は何らかしらの責務を持つモノとして捉えるため名詞用いる**

## interface

**インターフェイスの名前に形容詞を用いることがある。形容詞を用いることでクラスの持つ性質を説明することができるようになる。**

## 記号の呼び名

汎用的に呼ばれているものを記載する

[]: ブラケット

## api ディレクトリ構造 example

```
|- @types ライブラリの型定義の拡張
|- application domain/serviceの実装部分
|- db Migrationファイル
|- domain
    |- entity ORMの定義が書かれている
    |- service できることの記載
|- handler ここがメインのHandler実装
    |- [旧]{tmp} ここはリファクタで消える
|- helper entityの拡張
|- interface
    |- endpoint
    |- params
        |- builder Entityなどからtypesに整形するための処理
        |- error エラーの定義が書かれている
        |- schema Validationに使っていたのちに消す予定
        |- types Request, Responseの値の型を定義している
    |- router ここがAPIの要件
|- job Job群
|- lib 各種ライブラリや、拡張
    |- aws
    |- express
    |- file
    |- random
    |- slack
    |- time
    |- twilio
    |- vivox
|- middleware ミドルウェア群が書かれている
|- [旧] models
|- platform - Auth系の処理がまとまっている
|- registration - entityごとでDBへのアクセスのまとまった処理
|- setting - 設定ファイルが入っている
|- [旧] utils - utility
```

## バージョン

[参考URL](https://docs.oracle.com/cd/E19253-01/819-0395/chp-vers-1/index.html)

x.y.z

x : メジャーな
x.y : マイナーリリース
x.y.z : マイクロリリース


## プロセスとスレッド

[参考URL](https://lab.mo-t.com/blog/andonlabo-process-and-thread)

---

## プロセス(docker.mdで図がある。)

**OSから見える処理の単位**

以下はプロセスの情報を列挙する。
- 1プロセス1CPUの関係。
- メモリ空間を共有していない
- 他のプロセスのメモリにはアクセスできない
- プロセス間の同期が難しい
- スレッドと比較して1プロセス毎の情報量が多い
- 情報量が多いので切り替えが遅い
- マルチスレッドプログラムと比較してメモリ効率が低い
- 仮想アドレスと物理アドレスの解決が高コストのため切り替えが遅い
- マルチスレッドプログラムと比較して大量のメモリが使用できる
- マルチプロセッサの場合、（一般的に）シングルプロセスマルチスレッドプログラムよりもマルチプロセスプログラムの方が高速

## スレッド

**プロセスの中で並列的に処理を行う**仕組み

以下はスレッドの情報を列挙する。
- メモリ空間を共有している
- 他のスレッドのメモリにアクセスできる
- スレッド間の同期が容易
- スレッドセーフな実装にする必要がある
- メモリを共有しているので、他のスレッドに予期せぬ影響を与えてしまうことがある
- プロセスと比較して、1スレッド毎に必要な情報量が少ない
- 情報量が少ないので切り替えが早い
- マルチプロセスプログラミングと比較してメモリ効率が高い
- マルチプロセスプログラミングと比較して大量のメモリ確保が行えない
- 非同期に実行できる処理がある場合は、（一般的に）シングルスレッドプログラムよりもマルチスレッドプログラムの方が高速


---

>実際のプログラムでは、プロセスやスレッドを都度生成する事は稀です。
>高コスト、メモリリーク、生成できない可能性がある等の問題があるからです。
>起動時に必要数を確保しプログラム終了時まで破棄しないスレッドプール等の仕組みが使われます。


## 式と文

プログラムを組み立てるのに必要な式と演算子

- 式
式とはリテラルや変数、演算子、メソッドなどを組み合わせたもの
**式は何らかの値を返す**

- 文
文（Statement）とは値を返さないもの（=変数に代入できないもの）

## ひとつの文章にまとめない方がいい

以下の書き方は良い習慣ではない。
というのも一般的な開発環境（デバッガー）ではコードの実行を中断し**ブレークポイントは行単位でしか設定できない**
そのため短い文であっても複数の文を1行にまとめないが鉄則

```ruby
name = '山田'; puts(name)
```

## リテラル

リテラルは数値や文字列などのデータを**コード中で表現**する方法

- リテラル表現
`108, 'Hoge', [1,2,3]`のようなリテラルをかくことは、すべて特定の型（クラス）に応じたインスタンスを生成することと同義。
この例だtとInteger, String, Arrayクラスのインスタンスが生成される。
リテラル表現はインスタンスを生成する手軽な手段だが、すべての型（クラス）で用意されているわけではない。
数値、文字列などよく利用するものについていちいち利用するたびにインスタンス化を意識させるのは面倒なためより直接的に表現できるリテラルが用意されているだけ。
一般的なクラスはnewというメソッドを利用してインスタンス化する。

## 第一級オブジェクト(ファーストクラスオブジェクト)

第1級オブジェクトというのは数値や文字列のような、変数に割り当てられたり、なんらかの計算処理ができたりといった、プログラミングの基本機能が使える対象のことを指す。

## 関数とサブルーチンの違い

関数は値を返すのに対してサブルーチンは値を返さないという違い。
どちらも同じようなものであるものである（実際にほとんどの言語でサブルーチンと関数の区別は存在しない）

## サブルーチン

サブルーチンとは**メインの処理（ルーチン）**から呼び出される別の処理という意味合いで、多くの場合関数と同じ意味で使われる。

## メソッド

クラスの中に定義された関数のことをメソッドと呼ぶ。

## インスタンスメソッドとクラスメソッド

- お互いの理解

インスタンスメソッドは**インスタンスの情報を取得・操作するためのもの**
クラスメソッドは**クラスの情報を取得/操作するためのもの**

## 高階関数(こうかいかんすう)

関数を受け取る関数を高階関数と呼ぶ。
そして関数を返す関数は高階関数と呼ぶ。

```ts
function sayHello() {
  return () => {
    console.log('hello!');
  }
}
```

## コールバック関数

[参考URL](https://sbfl.net/blog/2019/02/08/javascript-callback-func/)

広義だと単なる「高階関数に渡すための関数」
自分で直接実行するのではなく、相手に実行してもらうのがコールバック関数

## CLIを作りたいのであれば

コマンドラインからの引数をparseする考えを持つ。

コマンドラインツール用に引数をパースするライブラリ
rubyのcommanderをインスパイアして作られている

>頻繁に発生するオペレーション作業を自動化するなど、ちょっとしたCLIをツールを自作したいケースはよくあると思います。Shellでサクッと終わらせてもよいのですが、Web APIを利用するようなケースなど、高級言語で開発した方が効率か良いですし、副産物としてマルチOSで動作させられるおまけがついてきます。どうせやるなら今っぽいCLIを作りたい。ということで、Vue.js、Reactを参考に、commanderモジュールを使ったNodejsでのCLI実装について紹介します。

## ミュータブルとイミュータブルの違い

ミュータブル
オブジェクトをそのままに中身だけを変更できることを意味する。

イミュータブル
一度作成したオブジェクトの中身を書き換えることはできない。

- ミュータブル
参照先の変わる更新と変わらない更新がある。

参照先の変わる更新
```rb
data = [1, 2, 3]
data = [4, 5, 6] # 新たな参照先が格納される

```

参照先の変わらない更新
```rb
data = [1, 2, 3]
data[2] = 6 # 参照先の差している配列のインデックスを更新する
p data # [1, 2, 6]
```

- イミュータブル
プログラミング言語によって変わると思うがプリミティブ型はイミュータブル

```rb
num1 = 5
num1 += 1 # 値の更新によって常に参照先が変わる。
```

## レシーバー(receiver)

メソッド呼び出しの文脈で「.」の前に位置するオブジェクトのことをレシーバーと呼ぶこともある。
オブジェクト指向ではメソッドを呼び出すとはオブジェクトに対して何らかの司令/メッセージを送信することと見なされる
つまりそのメッセージの受け取り手が（receiver）オブジェクトである。

---

## プログラミングパラダイム

[参考URL](https://agency-star.co.jp/column/procedural-linguistics)

オブジェクト指向型や手続き型のようなプログラムの見方・考え方の枠組みのことを**プログラミングパラダイム**という

### 種類

- 構造化プログラミング
- 宣言型プログラミング
- イベント駆動型プログラミング
- スタック指向プログラミング
- コンポーネント指向プログラミング
- アスペクト指向プログラミング（AOP）

命令型は死後の様子。  
今は命令型に手続きの定義と呼び出しを加えることで手続き型と同じように扱われている模様。


### 宣言型
[宣言型、命令型、手続き型の違いを考える](https://zenn.dev/wooootack/scraps/18f19f9c549bf4)
[命令型と宣言型の違い](https://jp.quora.com/%E5%91%BD%E4%BB%A4%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%A8%E5%AE%A3%E8%A8%80%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%81%95)

### 最近は手続き型よりも宣言型の方が優れている（？）ような風潮があるのはなぜか？

宣言型は参照透過性があるので、同じ引数で呼び出しを行えば、同じ結果を返すことを保証できる
手続き型の場合は参照透過性がないため、同じ結果を返すとは限らない
-> つまりDDDでいうドメインモデルは宣言型ではないということか？



---

## 同期処理と非同期処理

多くのプログラミング言語には**コード評価**の仕方として同期処理（sync）と非同期処理（async）という大きな分類がある。

---

## 並行と並列
[参考URL](https://spirits.appirits.com/doruby/9199/#:~:text=%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%8C%E8%A4%87%E6%95%B0%E3%81%AE%E5%8B%95%E4%BD%9C,(parallel)%E3%81%A8%E8%A8%80%E3%81%84%E3%81%BE%E3%81%99%E3%80%82)

### 並行(concurrent)

横に移動してスレッドを処理する。意味がわかりやすい。
複数のタスクを一人でタスクスイッチしながら同時に捌いているイメージ。

つまり、ある瞬間に2つの作業を同時に行なっているというわけではない


## 並列（parallel)

複数の作業が本当の意味で同時に進行している状態。
これが本当の意味で複数

## 型精査方法
[参考URL](https://qiita.com/suin/items/52cf80021361168f6b0e)
型の互換性判断について2種類ある。

### 公称型 - 継承関係に着目する(nominal typing)

公称型では型の互換性は**オブジェクト同士の継承関係(is-a関係)に着目して判断している。**
JavaやPHPなどはこの型システムを採用している。
>例えば、AnimalとUserの2つのクラスが、全く同じnameプロパティを持っていて、同じように取り扱えたとしても、お互いに継承関係が無い場合は、User型の変数にAnimalインスタンスを代入することも、その逆もできません。互換性がないわけです。逆に、CatクラスがAnimalを継承している場合、Animal型の変数にCatは代入可能です。CatはAnimalとの互換性があることになります。

つまり同じ継承先（親）を継承していれば互換性があるとみなす。
>あくまで、継承関係があるかが大事。「能力」よりも「血統」重視の型システムと言えそうです。

- TypeScriptでも公称型を実現したい
[参考URL](https://qiita.com/suin/items/ae9ed911ebab48c98835)

1. 適当なプロパティを増やしてまったく同じ構造へならないようにする。
```ts
type Book = { name: string, hoge: any }
type Person = { name: string, fuga: any }
```

2. シンボルを使用
うっかり事故は防げない。そのためシンボルを使用する。
```ts
const bookNominality = Symbol()
type Book = { name: string, [bookNominality]: any }
const personNominality = Symbol()
type Person = { name: string, [personNominality]: any }

// 上で定義したシンボルは実行時には不要のため、コンパイル後のJSコードに残ら内容declareする
declare const bookNominality: unique symbol
type Book = { name: string, [bookNominality]: any }

declare const personNominality: unique symbol
type Person = { name: string, [personNominality]: any }
```

### 構造的部分型 - プロパティに着目する(structural sub typing)

構造的部分型は継承関係ではなく**オブジェクトが持っているプロパティが互換しているかどうかに着目して判断している。**
つまり構造が同じかどうか。
TypeScriptやGolang?が採用している。

>例えば、AnimalとUserの2つのクラスに、継承関係がなかったとしても、同じnameプロパティを持っていれば、User型の変数にAnimalを代入できます。その逆も可能です。つまり、お互いに互換性があるわけです。

```ts
class Animal {
  public name: string = ''
}

class User {
  public name: string = ''
}

let user: User = new User()
let animal: Animal = new Animal()
user = animal // OK
animal = user // OK
```

>「血統」よりも「能力」重視なのが構造的部分型と言えそうです。

## スコープ
[参考URL](https://wemo.tech/904)  
[JSのスコープ話](https://www.i-ryo.com/entry/2020/02/18/063604)  
グローバルとローカルがある。
しかしローカルについて気にすると、ローカル変数の有効範囲は関数の定義時に決まるものなのか、他の場所で呼び出した時にも更新されるものなのか、

>これについては、実は各プログラミングごとに決まっていて、それぞれ「レキシカルスコープ（静的スコープ）」と「ダイナミックスコープ（動的スコープ）」と呼ばれています。

### レキシカルスコープ(静的)

JS,Ruby,Java,Pythonなどが該当  
レキシカルスコープは**関数を定義した時点**でスコープが決まります。

- JSにアロー関数ができた理由
>thisの束縛の話！通常の変数は「レキシカル（静的）」だけどthisは「ダイナミック（動的）」だ！  
>これを無くしたい、という意図でアロー関数は作られたわけだ。

### ダイナミックスコープ(動的)

ダイナミックスコープは**関数を実行した時点**でスコープが決まります。

## Reflection

プログラムの実行過程でプログラム自身の構造を読み取ったり書き換えたりする技術のこと。

## DI(Dependency Injection)

DIを使う理由は、結合度の低下・てスタビリティの向上が主な理由。

---

## キャスト
[参考URL](https://qiita.com/querykuma/items/e7667adba1477eb7d3a5)

### アップキャスト

extends元の基底クラスの型にキャストすることをアップキャストと呼ぶ
TypeScriptのアップキャストは明示しないでできる。

```ts
class A {
  a = 1;
}
class A2 extends A {
  a2 = 2;
}
var a2 = new A2;
function testA(a: A) {
  console.log(a.a); // 1を出力
}
testA(a2); // A2からAにアップキャスト
```

### ダウンキャスト

ダウンキャストは明示する必要がある。明示しないとエラーになる。
extends先の派生クラス型にキャストすることをダウンキャストと呼ぶ。
※継承先がダウンとする。
```ts
class A {
  a = 1;
}

class A2 extends A {
  a2 = 2;
}
var a = new A;
console.log((a as A2).a2); // as A2でダウンキャストを明示
```

## プログラミングにおけるシグネチャ
[参考URL](https://e-words.jp/w/%E3%82%B7%E3%82%B0%E3%83%8D%E3%83%81%E3%83%A3.html)

プログラミングの分野では、関数やメソッドの名前、引数の数やデータ型、返り値の型などの組み合わせのことをシグネチャという。  
言語によっては、同じクラスなどの中で名前が同じだが引数の型などが異なるメソッドを複数同時に宣言することができる場合もあり、それらはシグネチャによって識別される。

## インクリメンタルビルド

ビルド処理効率化のための仕様。
これはコードやデータソースの変更内容に基づき、更新が必要なHTMLファイルのサブセットのみを生成することで、ビルドの高速化を図る機能。

## オブジェクト

```ts
const obj = {
  // フィールド: プロパティ
  a: 20
}
```

## カリー化
[TypeScriptでのカリー化](https://zenn.dev/tsucchiiinoko/articles/54076f7b135246)

複数の引数を持つ関数を、1つの引数を受け取る関数の連鎖にすること。
カリー化のメリットは**引数を1つずつ処理していくことで、部分適用がしやすくなる。**
つまり、**関数を実行する際に共通化した処理を部分適用していくことで**
その関数をより汎用的に使えるようになるということができます。

## ストリーム
[wiki](https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0))

ストリームとはデータを比較的小さい単位が連続したものと捉え**上流から下流へ流れるものとみなし**そのデータの入出力・送受信（途中段階を含む）を最小限の滞留とさせ低遅延処理となるように扱う形態を指す。  
またその操作のための抽象データ型を指す

## シリアライズ

>まず、シリアライズとは何かを説明します。
>簡単に言うと、データをファイルとして保存できる形式に変換することを、シリアライズといいます。
>通常、オブジェクトデータはオブジェクトグラフと呼ばれるデータ構造になっており、一つを保存すれば良い、とはならないようです。
>リンク状になったデータを保存できるように直列に繋ぐ作業を、シリアライズという（らしい）