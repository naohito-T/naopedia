# 言語

言語について記載していくフォルダ

下にこのディレクトリの各ファイルへのリンクを入れても良いかも

## 新規のプロジェクトに入る時の心構え

全体がわかっていないとコードを書くことが絶対わからない。
必ず新規プロジェクトに入った際には必ず仕様やドキュメントをしっかりみること。

## プログラムを書く前に考えること

書きながらロジックを構成していくのは上級者。
そうなるべきだが、まずは紙でも良いのでロジックを考える。
ロジックが完成してから書く癖を。
後は遅くなる原因としては仕事の使用

## 変数/メソッド名 コメント

原則使わなくて済む方が良い。

- コメントなしで意味が伝わる命名をする
- 関数の引数は命名だけではなく、TypeScriptの情報量を増やす

## メソッド名

**メソッド名の場合は動詞や助動詞を用いて命名する**

[参考URL](https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6)

このパターンで適宜考えないといけない

- 真偽値を返すメソッド
- 必要に応じてしか実行されない処理をするメソッド
- 非同期処理に関連するメソッド
- コールバックメソッド
- コレクションの操作に関するメソッド
- 状態に関するメソッド
- オブジェクトのライフサイクルを扱うメソッド
- データに関するメソッド


## クラス名

[参考URL](https://qiita.com/KeithYokoma/items/ee21fec6a3ebb5d1e9a8)

**クラス名は何らかしらの責務を持つモノとして捉えるため名詞用いる**

## inteface

**インターフェースの名前に形容詞を用いることがある。形容詞を用いることでクラスの持つ性質を説明することができるようになる。**

## api ディレクトリ構造 example

```
|- @types ライブラリの型定義の拡張
|- application domain/serviceの実装部分
|- db Migrationファイル
|- domain
    |- entity ORMの定義が書かれている
    |- service できることの記載
|- handler ここがメインのHandler実装
    |- [旧]{tmp} ここはリファクタで消える
|- helper entityの拡張
|- interface
    |- endpoint
    |- params
        |- builder Entityなどからtypesに整形するための処理
        |- error エラーの定義が書かれている
        |- schema Validationに使っていたのちに消す予定
        |- types Request, Responseの値の型を定義している
    |- router ここがAPIの要件
|- job Job群
|- lib 各種ライブラリや、拡張
    |- aws
    |- express
    |- file
    |- random
    |- slack
    |- time
    |- twilio
    |- vivox
|- middleware ミドルウェア群が書かれている
|- [旧] models
|- platform - Auth系の処理がまとまっている
|- registration - entityごとでDBへのアクセスのまとまった処理
|- setting - 設定ファイルが入っている
|- [旧] utils - utility
```

## バージョン

[参考URL](https://docs.oracle.com/cd/E19253-01/819-0395/chp-vers-1/index.html)

x.y.z

x : メジャーな
x.y : マイナーリリース
x.y.z : マイクロリリース


.htaccessと.htpassword
8文字のpassで認識している。

## プロセスとスレッド

[参考URL](https://lab.mo-t.com/blog/andonlabo-process-and-thread)

---

## プロセス(docker.mdで図がある。)

OSから見える処理の単位
1プロセス1CPUの関係
メモリ空間を共有していない
他のプロセスのメモリにはアクセスできない
プロセス間の同期が難しい
(スレッドと比較して)1プロセス毎の情報量が多い
情報量が多いので切り替えが遅い
(マルチスレッドプログラムと比較して)メモリ効率が低い
仮想アドレスと物理アドレスの解決が高コストのため切り替えが遅い
(マルチスレッドプログラムと比較して)大量のメモリが使用できる
マルチプロセッサの場合、(一般的に)シングルプロセスマルチスレッドプログラムよりもマルチプロセスプログラムの方が高速

## スレッド

プロセスの中で並列的に処理を行う仕組み
メモリ空間を共有している
他のスレッドのメモリにアクセスできる
スレッド間の同期が容易
スレッドセーフな実装にする必要がある
メモリを共有しているので、他のスレッドに予期せぬ影響を与えてしまうことがある
(プロセスと比較して)1スレッド毎に必要な情報量が少ない
情報量が少ないので切り替えが早い
(マルチプロセスプログラミングと比較して)メモリ効率が高い
マルチプロセスプログラミングと比較して)大量のメモリ確保が行えない
非同期に実行できる処理がある場合は、(一般的に)シングルスレッドプログラムよりもマルチスレッドプログラムの方が高速


---

>実際のプログラムでは、プロセスやスレッドを都度生成する事は稀です。
>高コスト、メモリリーク、生成できない可能性がある等の問題があるからです。
>起動時に必要数を確保しプログラム終了時まで破棄しないスレッドプール等の仕組みが使われます。