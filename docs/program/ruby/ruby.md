# Ruby

[他言語からRuby入門について](https://www.ruby-lang.org/ja/documentation/ruby-from-other-languages/)

## Ruby他言語との違い

Perlの多くの部分を踏襲したRubyでしたが、1点決定的に異なる部分があります。それがRubyが純粋なオブジェクト指向言語である、という点。

後からオブジェクト指向の仕組みを取り入れたPHPとは異なり、**Rubyは最初からオブジェクト指向で記述できるよう開発された言語。実行はインタプリタ方式**

Ruby on Railsを使用した場合の最大のメリットは、**開発スピードで低予算でWebアプリを簡単に作ることができること。**

## Rubyのインデント

スペース2が基本

## Ruby コンパイラとインタプリタ

Rubyはインタプリタ型のプログラミング言語。
Rubyプログラムが記述されたソースコードを逐次解釈して実行する。
**Ruby 1.9以降の言語実装(YARV)では処理を高速化するためにテキストコードをいったん独自のバイナリーコードに変換してから実行する。**
現在のRubyはコンパイラとインタプリタの中間言語といえる。

## Rubyによってできること

1. Webアプリケーション
2. WebAPI
3. スクレイピング
4. スマホアプリ
5. 機会学習

## すべては値

式と文に違いはありません。 すべては値を持ちます。nilであっても例外ではありません。 Rubyでは次のように書くことが可能
**※if文を変数に入れることができる**

```ruby
x = 10
y = 11
z = if x < y
      true
    else
      false
    end
z # => true
```

## 不思議なメソッド名

Rubyでは、メソッド名の最後に疑問符(?)や感嘆符(!)が使われることがあります。 慣習的に、問い合わせ系のメソッドの最後には疑問符が使われます (例: レシーバが空の場合にtrueを返すArray#empty?)。 また、使用に危険を伴うメソッドの最後には感嘆符が使われます (例: selfあるいは引数の内容を書き換えるようなメソッド。exit!など)。 けれど、危険なメソッドすべてがこの慣習に従っているわけでも ないことに注意してください。 Array#replaceは、与えられた配列の内容で配列の内容を置き換えます。 この操作は、自身を変更しないようなメソッド名とは意に反する振る舞いをします。

## 時間

```ruby
Time.current
# Railsの独自のメソッドで、TimeWithZoneクラスを使用している。
# config.time_zone で設定したタイムゾーンを元に現在時刻を取得する。

Time.now
# Timeクラスを使用している。
# 環境変数TZの値。なければシステム(OS)のタイムゾーンを元に現在時刻を取得する。
```

## Ruby 定数

[参考URL](https://qiita.com/fursich/items/a1b742795cf10eebc73f)

- 定数参照
::演算子
>あるクラスまたはモジュールで定義された定数を外部から参照する ためには::演算子を用います。またObjectクラスで 定義されている定数(トップレベルの定数と言う)を確実に参照する ためには左辺無しの::演算子が使えます。

## $LOAD_PATHとは

ファイルを読み込むRubyのメソッド`load`や`require`がファイルを参照する時に使われるディレクトリパス群
application.rbにもrequire "rails"などと言った記述がありますが、これだけでどうやってRailsのGemファイルを参照しているのか疑問だが、$LOAD_PATHにパスが設定されているため。

## ブロック構文

Rubyに組み込まれたメソッドの中には、ブロック構文を使って処理や条件を指定可能なメソッドがある。

Rubyで使えるメソッドの中には引数の他に、`do ~ end`または`{}`で囲まれたブロック構文を利用するメソッドが多い。

**そして、ブロック構文は、doで始まり、endまでが範囲です。また、省略して{}で囲む書き方も可能。**

- ブロック構文の使い分け
厳密な違いは結合の強さが違い、`{}`が優先されるが、

## Rubyにおけるメソッドの呼び出し方

Rubyでメソッドを呼び出す場合、次の2種類があり、**どちらの方法が使われるかはメソッドによる**

1. メソッドと引数で呼び出す

メソッド名のみ、または、メソッドに続けて括弧内に引数を指定する方法です。引数は、値や変数の他、式も記述できます。

```ruby
hoge
hoge()
```

2. ブロック付きメソッドで呼び出す

do～endまたは{}で囲った制御構造を付けてメソッドを呼び出す方法です。eachメソッドなど、繰り返し処理の内容を記述する場合などで使われます。そして、do～end、または、{}内の制御構造がブロック構文です。

```ruby
hoge do 制御構造 end

hoge { 制御構造 }
```

## Rubyの変数

[変数](image/変数.png)

## Rubyでの文の終わり方

Rubyでは文の終わりを示すためのセミコロン(;)はない。
**改行が文の終わりとみなす**
そのため以下は一つの文
a = true; b = true; c = false;

## 数値

かつてFixnumクラスとBignumクラスがあった
現在はIntegerとFloatの2つがある。

気をつけこと

1. IntegerとFloatを計算したら自動的にFloatに変換される。
2. 整数同士の割り算の結果は常に整数になる。

## 文字列

気をつけること

1. テンプレートリテラルは二重引用符(")で囲まれた文字列の中に#{}があると展開してくれる。
2. **数字と文字列の連結** と **>で比較したりするとエラーとなる。**

**もちろん参照渡し**

## 配列

要素の番号は0から始まる。
現在の要素数より、大きな番号を指定して要素を取り出すと、何もないことを表すnilが返される

気をつけること
1. 要素数の数より大きな数を指定して要素を入れると可変してくれる。

```ruby
irb(main):011:0> ani = ['a','b','c']
irb(main):012:0> ani[8] = 'd'
irb(main):013:0> puts ani
a
b
c





d
=> nil
```

2. 配列に要素として、様々な雑多なオブジェクトを入れることができる(文字列・数字・オブジェクトをごちゃまぜ可能)
3. %w()の中にスペースで区切って文字列を並べると配列を簡潔に記述できる。文字列の中で式展開などを使いたい場合は%W()を使う

## デバッグで使うメソッド

inspect
オブジェクトの内容を読みやすい形にした文字列を返す。

p
putsと同じ結果を返す


## 式

**式は何らかの値を返す**
Rubyでは式と文の区別はあまりない(if文の結果を変数に入れられるため)

## 演算子

気をつけること

```ruby
=~ # 文字列と正規表現が一致するかを判定するRubyの演算子
```

## 条件式

気をつけること
条件式の結果は c = (a == b)のように取り出すことができる。trueかfalseを返す

a == bのようにある条件が成立しているかどうかを調べる式を**条件式という**

- 論理演算子
![論理](image/論理演算子.png)

## falsyな値

気をつけること

**0と空文字は真になる** → JSではfalseになっていた

条件式がfalseになるのは
falseかnilの時だけ


## if文

気をつけること
1. falsyな値に気をつける

if文を1行で終わらしたい場合
`if num % 2 == 0 then puts "偶数です" end`
※thenが必要

2. 後置のifを頻繁に使う

trueだったらputsをする。
`puts "偶数" if num % 2 == 0`

## unless

**条件式が正しくないときに**プログラムを実行する

```ruby
unless num % 2 == 0
  puts "偶数ではない"
end
```

**ifと同様に後置のunlessも使える**


## メソッド

**メソッド名の最後には?か!をつけることができる**

- ?と!がつくメソッド
? : ?がついたメソッドはtrueまたはfalseを返すことができる。
! : !がついたメソッドはそのオブジェクトの中身を変更することを表す(!がつかないメソッドはオブジェクトを変更せずに新しいオブジェクトを返す)
※メソッド名に?や!をつけるのはRubyの文法というより慣習。自分でメソッドを作る時も意識する。

気をつけること

1. 戻り値を返したい場合は、最後に変数名を1行書けば済む(Rubyではメソッド内で最後に実行された式の値が戻り値になる)
2. 引数がないmethodの場合は名前の記述だけで呼び出せる。
3. methodを呼び出す時に `triangle 11, 9`のようにかっこを省略することもできる。
4. `&:メソッド`の書き方でブロックを渡せる

```ruby
def triangle(base, height)
  result = base * height / 2.0 # resultが戻り値になる。
end

```

## ローカルスコープ

ローカルスコープとなるところ
1. method内
2. ブロック内

気をつけること
**if文やunless式の中のローカルスコープはスコープがない。**

## ブロック

気をつけること
1. ブロックはdoとendの代わりに {}で囲むことができる
`10.times { |i| print i, ","}`
2. メソッドに引数とブロクを両方渡すことができる
```ruby
2.upto(6) do |i|
  print i, ", "
end
```

Rubyでの面白い特徴の一つ。
Rubyではmethodを呼び出す時にブロックと呼ばれるコードのかたまりを渡すことができる。
**※ブロックは繰り返しの処理によく使われる**

簡潔にいうと
ブロックとは**doからendまでのプログラムのひとかたまりの部分**
ブロックには | と |で囲んでブロックパラメータを指定できる。

## 配列

要素を順番に処理するのはeachメソッドを使う

```ruby
arr = ["a", "b", "c", "d", "e", "f"]
arr.each do |item|
  print item + ", "
end
```

## シンボル

**メソッドや変数の名前だけではなく、アプリケーションで特別な意味を持つ名前を表すのにもシンボルが使われる。**

Railsの開発でよく使われるのはハッシュのキーをシンボルにすること

rubyのシンボルは名前を表すオブジェクト。
シンボルを作るには`:cat`のように名前のまえに:(コロン)を付ける

---
--- object ---

## オブジェクトのこぴー

参照渡しを避けるには、dupメソッドを使用。全ての値は持っている。

## クラス

## インタンスメソッド

クラスの中にdef ~ endでインスタンスメソッド


## インスタンス変数

@を付けた変数はクラスのインスタンスごとに作られるインスタンス変数

気をつけること
1. インスタンス変数の初期値はnil

## アクセス修飾子

![参考](image/アクセス修飾子.png)

**2014年にリリースされた、言語仕様で独立した行にprivateとかくと次に独立したpublicまたはprotectedが出現するまでの間に定義されたメソッドは全てプライベートメソッドとなる。**



## initialize method (コンストラクタか？)

newでインスタンスを作成する時に自動で実行されるメソッド


## レシーバとsele

`robo.move`のようにメソッドを呼び出す対象をレシーバ(受け取るもの)
Rubyでは、メソッドの呼び出しをオブジェクトに対してメッセージを送信すると考えるため
※レシーバを省略すると現在のオブジェクトを表すselfがレシーバと見なされる。

## オブジェクト内のメソッドにアクセスするには？

考えていること
```ts
class A {
  private a: int = 0;
  construct(a: int) {
    this.a = a;
  }
}

const a = new A(1);
```
上記じゃアクセスできない

- アクセサメソッド

**なんと、Rubyではオブジェクト内のデータにアクセスするには、メソッドを書かなければいけない**
**アクセサメソッドでやり取りできるデータを属性と呼ぶ。**

- 属性の実態
属性の実態は変数ではなく、**インスタンス変数とメソッドの組み合わせである。**

## アクセサメソッドの簡略

簡略な書き方がある。

```ruby

class Robot
  attr_reader :name # 読み出し用メソッドが
  attr_writer :name # 書き込み用メソッドが
def

# 読み書き両方のメソッドを作りたいとk
class Robot
  attr_accessor :name 
  attr_accessor :name, :name2 # いくつも作りたい時
def

```

## アクセサメソッドのクラス内と外側の呼び出し違い

アクセサメソッドはrobo.nameの様にクラス外から呼ぶ

クラス内ではレシーバを省略しnameだけで呼べる

```ruby
def change_name(new_name)
  old_name = name # method呼び出し
  name = new_name # 注意。nameはローカル変数になる
  self.name = new_name # 正しい呼びだし
end

```

## クラスメソッド(多分JavaでいうStatic メソッド)

- 定義

```ruby
class A 
  # クラスメソッドの定義
  def self.b
  end
end
```

- クラスメソッドの書き方(別)
こちらの書き方が好きなプログラマーも多い

```ruby
class Robot
  class << self # この間にはいくつもクラスメソッドを置くことができる。
    def lodad(fname)
      # クラスメソッドのないよう
    end
  end
end
```

## 定数

1. クラス内で大文字で始めるとクラス定数
2. クラス外で定義すると、その定数はどこからでも参照できる。

## 継承とミックスイン

Rubyには既存のクラスを拡張する方法が色々ある。
Rubyではクラスの継承は単一継承

## モジュール(普通に使う分にはutilとして使えるのでは？)

```ruby
module A
# モジュールにメソッドをまとめておく
end
```

クラスにモジュールを取り込むことをミックスインと呼ぶ

- 名前空間としてのモジュールとクラス(これ認可に使えるのでは？)
ミックスイン以外にモジュールは名前空間として使うことができる。

`モジュール名::クラス名`でクラスを参照できる


## Kernelモジュール

Kernelモジュールはputsの様によく使われるメソッドを集めたモジュール
ObjectクラスはKernelモジュールをミックスインしており、**全てのクラスはObjectクラスのサブクラス**

## Class自体

```ruby
class Robot
end

robo1 = Robot.new
robo2 = Robot.new
```

クラスRobotは、Robotクラスを表すオブジェクトを指している。
Robotクラスを表すオブジェクトも何かのクラスのインスタンス。
→そのクラスはClassクラス。Classクラスはクラスに関する機能を備えたクラス。

RobotはClassクラスのインスタンスを参照する定数のため普通の変数のように別の変数で参照したり、メソッドの引数に渡すことができる

```ruby
kkass = Robot # Classオブジェクトを指す
r = kkass.new # Robot.newと同じ
r.kind_of?(Robot) # クラスはメソッド引数にモナれる

```

---

## RubyのPATH捜査について

- require
requireはロードパスを起点として相対パスでファイルを検索する
requireが取り込み対象として捜査するディレクトリは組み込み変数の`$LOAD_PATH`に格納される
`$ ruby -e 'puts $LOAD_PATH`

- require_relative
その呼び出しているファイルからの相対パス

## Railsの場合

Railsにはrequire関連で特殊な機能がある。

まず自分で定義した**ModelやControllerなどのClassやRailsが自動的にrequire対象としてくれる。**




---