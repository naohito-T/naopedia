# 独習ruby

読んだまとめ

## デバッグメソッド

puts

p
pメソッドはputsに似ているが値をより型情報のわかる形で出力する。
たとえば、文字列であれば`"Hoge"`のようにクウォート付きで出力する。配列ならブラケット付きで出力。

## rubyコマンド

`ruby -w`オプションを渡すとコードに問題があるい場合に警告を表示してくれる

---

## データ型

動的型付け。
ただしデータ型をまったく意識しなくても良いわけではない。
値を演算/比較する場面ではデータ型によって挙動が変化する。

## ヒアドキュメント

## シンボル型(Symbol)

シンボルは**文字列に比べてメモリ消費が少なく、比較（検索）のためのパフォーマンスも高い型**

シンボル（Symbol）はシンボル（モノの名前）を表すための型。

```rb
head = :title
puts head # 結果 title
```

`:名前`の形式で表す。文字列に似ているが以下の点で異なる

- 値を変更で機内
- 同じであるかを判定する場合、文字列よりも高速
- 同じ値であれば同じメモリで管理されるのでメモリの利用効率が高い
- 文字列よりも少しだけスッキリ表現できる。

## nil型(ニル)

nil型は**ある変数が値を持たないこと表す。**
より正確にはNilClassという型があり、nilはその値を格納した擬似変数

```sh
irb(main):003:0> puts 10
10
=> nil
```

=> 以降はputsが返す値を表す。
putsメソッドは指定された値を出力するだけで（voidみたいなものか）何らかの値を返すわけではない（=nilを返す）わけ

## 擬似変数

true/false、nilの他にも擬似変数が用意されている
**擬似変数は変数とはいうが再代入ができない**

self
現在のレシーバー

__FILE__
実行中の`.rb`ファイル

__LINE__
実行中の行（番号）

__ENCODING__
現在のコードの文字エンコーディング

## 配列

配列の値は互いに異なっていても構わない。
が、一般的には1つの配列内では型を統一するのが普通

配列ショートカット

```rb
p %w!山田 佐藤! # ["山田", "佐藤"]

p %i!isbn title price! # [:isbn, :title, :price]
```

式展開を有効
w → W
i → I


## 連想配列(キーは文字列型)

ハッシュは**名前をキー**にアクセスできる配列。
言語によっては連想配列、マップなどとよばれる。
※キーが重複した場合、**後半に宣言したキー**で上書きされる。

構文
```ruby
data = {
    'name' => '鈴木',
    'address' => '営業',
}

puts data['name']
```

## ハッシュ(連想配列)

**ハッシュキーはシンボル**にするのが必須

構文
```ruby
data = {
    :name => '鈴木',
    :address => '営業',
}

puts data[:name]
```

シンプルな構文
キーがシンボルの場合、さらにシンプルに`キー:値`で表すことも可能
```ruby
data = {
    name => '鈴木',
    address => '営業',
}

puts data[:name]
```

## 参照/値渡し

Integer/Floatの一部の値/true/false/nil/シンボル

これらの型は**処理効率上の理由**から（参照値ではなく）実際の値そのものが変数に格納される（このような実装を即値と呼ぶ）
ただし、これらの型ではこれまた処理効率上の理由から同じ値は同じオブジェクトとして管理される（同じ値であれば同じ参照値が返される）

## 定数

定数は変更できない変数と捉えるのは違う。
再代入できない変数（つまり変数であっても値を変更できてしまう場合がある）
→そもそもRubyでは再代入しても警告しか発生しない

- イミュータブル（プリミティブ）

```rb
VALUE = 10
VALUE = 15 # エラー（警告）
```

- ミュータブル

```rb
VALUE = [10, 20, 30]
VALUE = [1, 2, 3] # エラー（警告）
VALUE[0] = 100 # 動作してしまう
```

## 多重代入

1. 同時代入
複数の変数/定数に対してまとめて値を代入するための仕組み
```rb
a, b = 12, 2
puts a # 12
puts b # 2
```

2. 配列分解
配列を分解もできる（左辺の変数と右辺の要素数は一致していなくても良い）
→余った変数はnil（空）となる。
```rb
data = [1, 2, 3]
a, b, c = data
```

3. **配列分解（*であまった値をすべて代入）**
※*（アスタリスク）は末尾でなくても構わない。また値が入らなかった場合はからの配列が生成される。
```rb
data = [1, 2, 3, 4, 5]
a, *b, c = data
```

---

## 制御構文

Rubyの制御構文はすべて式（つまり値を返す。返す値がなければnil）

---
条件式が真の場合に命令を実行する

### if(文)

- 後置if命令
else節がないのであれば、後置ifを使う

**note**
後置ifで変わるニュアンス
前置構文では「条件が正しければしなさい」条件が主体
後置構文では「しなさい。条件が正しければ」処理そのものが主体

### if(式)

式としても利用可能（つまり値を返し変数に代入することができる）
if式では最後に評価された値を返す。

---
条件式が偽の場合に実行するunless

### unless

否定は人間の頭にとって把握しにくいもの。
※unlessのelseは否定の否定はかえって理解しづらいのでやめる。

```rb
unless 条件式
    # 条件式が偽の時に実行する処理
else
    # 条件式が真の時に実行する処理
end 
```

- 後置unless

### case ... when

switchのこと

---

## 例外処理

例外処理とは、あらかじめ発生するかもしれないエラーを想定しておき**実行を継続できるよう処理する。または安全に終了させるための処理のこと**

```rb
begin
    # 例外が発生するかもしれないコード
rescue 例外の種類 => 例外変数
    # 例外発生時の処理
end
```

---

第5章
最初らへん重要なことが書いてある

## インスタンス構文

クラスによってはnewメソッドの代わりにインスタンス生成のための専用メソッドが用意しているものもある。

例
```rb
t = Time.now # 現在時刻を表すTimeインスタンスが生成される
```

構文
```rb
a = クラス名.new()
```

## require

組み込みは読み込み不要だが、標準添付ライブラリ（Rubyと一緒にインストールされる）はRuby本体とは別のためあらかじめ読み込む必要がある。

## &.(ぼっち演算子) Safe Navigation Operator

実際のコーディングで**オブジェクトがnilではない時だけ、そのメンバーにアクセスしたいまたnilの場合はそのままnilを返す**
という状況はよくある。

このような処理をRubyでは`&.`で簡単にd系r。

```rb
str = nil
p str&.upcase # 結果 nil strがnilでもエラーにならない。
```

## キーワード引数

引数はカンマ区切りで値を列挙するのが基本だが、メソッドによっては`名前: 値`の形式で渡せる場合もある。

## 日付/時刻

組み込みのTimeクラスを利用すれば十分。
DateTimeは非推奨になっている。

## モジュール

モジュールとは再利用可能なコード（メソッド/定数）を束ねるための仕組み。
クラスと意味的には似ているが、以下のような**制約**がある。

- インスタンスを生成できない
- 継承できない

断片的なクラスみたいな感じ、以下の用途がある

- アプリ共通の機能を束ね、特定のクラスにインクルードする（ミックスイン）
- 共通の関数メソッド/定数を束ねる
- 名前空間を定義する

