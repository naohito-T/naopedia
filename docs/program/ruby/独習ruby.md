# 独習ruby

読んだまとめ

## デバッグメソッド

puts

p
pメソッドはputsに似ているが値をより型情報のわかる形で出力する。
たとえば、文字列であれば`"Hoge"`のようにクウォート付きで出力する。配列ならブラケット付きで出力。

## rubyコマンド

`ruby -w`オプションを渡すとコードに問題があるい場合に警告を表示してくれる

---

## データ型

動的型付け。
ただしデータ型をまったく意識しなくても良いわけではない。
値を演算/比較する場面ではデータ型によって挙動が変化する。

## ヒアドキュメント

## シンボル型(Symbol)

シンボルは**文字列に比べてメモリ消費が少なく、比較（検索）のためのパフォーマンスも高い型**

シンボル（Symbol）はシンボル（モノの名前）を表すための型。

```rb
head = :title
puts head # 結果 title
```

`:名前`の形式で表す。文字列に似ているが以下の点で異なる

- 値を変更で機内
- 同じであるかを判定する場合、文字列よりも高速
- 同じ値であれば同じメモリで管理されるのでメモリの利用効率が高い
- 文字列よりも少しだけスッキリ表現できる。

## nil型(ニル)

nil型は**ある変数が値を持たないこと表す。**
より正確にはNilClassという型があり、nilはその値を格納した擬似変数

```sh
irb(main):003:0> puts 10
10
=> nil
```

=> 以降はputsが返す値を表す。
putsメソッドは指定された値を出力するだけで（voidみたいなものか）何らかの値を返すわけではない（=nilを返す）わけ

## 擬似変数

true/false、nilの他にも擬似変数が用意されている
**擬似変数は変数とはいうが再代入ができない**

self
現在のレシーバー

__FILE__
実行中の`.rb`ファイル

__LINE__
実行中の行（番号）

__ENCODING__
現在のコードの文字エンコーディング

## 配列

配列の値は互いに異なっていても構わない。
が、一般的には1つの配列内では型を統一するのが普通

配列ショートカット

```rb
p %w!山田 佐藤! # ["山田", "佐藤"]

p %i!isbn title price! # [:isbn, :title, :price]
```

式展開を有効
w → W
i → I


## ハッシュ(連想配列)

ハッシュは**名前をキー**にアクセスできる配列。
言語によっては連想配列、マップなどとよばれる。
※キーが重複した場合、**後半に宣言したキー**で上書きされる。

構文
```ruby
data = {
    'name' => '鈴木',
    'address' => '営業',
}

puts data['name']
```

## ハッシュ(連想配列)

**ハッシュキーはシンボル**にするのが必須

構文
```ruby
data = {
    :name => '鈴木',
    :address => '営業',
}

puts data[:name]
```

シンプルな構文
キーがシンボルの場合、さらにシンプルに`キー:値`で表すことも可能
```ruby
data = {
    name => '鈴木',
    address => '営業',
}

puts data[:name]
```

## 参照/値渡し

Integer/Floatの一部の値/true/false/nil/シンボル

これらの型は**処理効率上の理由**から（参照値ではなく）実際の値そのものが変数に格納される（このような実装を即値と呼ぶ）
ただし、これらの型ではこれまた処理効率上の理由から同じ値は同じオブジェクトとして管理される（同じ値であれば同じ参照値が返される）

## 定数

定数は変更できない変数と捉えるのは違う。
再代入できない変数（つまり変数であっても値を変更できてしまう場合がある）
→そもそもRubyでは再代入しても警告しか発生しない

- イミュータブル（プリミティブ）

```rb
VALUE = 10
VALUE = 15 # エラー（警告）
```

- ミュータブル

```rb
VALUE = [10, 20, 30]
VALUE = [1, 2, 3] # エラー（警告）
VALUE[0] = 100 # 動作してしまう
```

## 多重代入

1. 同時代入
複数の変数/定数に対してまとめて値を代入するための仕組み
```rb
a, b = 12, 2
puts a # 12
puts b # 2
```

2. 配列分解
配列を分解もできる（左辺の変数と右辺の要素数は一致していなくても良い）
→余った変数はnil（空）となる。
```rb
data = [1, 2, 3]
a, b, c = data
```

3. **配列分解（*であまった値をすべて代入）**
※*（アスタリスク）は末尾でなくても構わない。また値が入らなかった場合はからの配列が生成される。
```rb
data = [1, 2, 3, 4, 5]
a, *b, c = data
```

---

## 制御構文

### if

- 後置if命令
else節がないのであれば