# table

DBのtableについて記載しておく。

## ユニーク制約

他行の値と重複してはダメな制約。

## データ型
[参考URL](https://tech.tabechoku.com/entry/2020/06/15/132518)

以下、型を選ぶ時に気をつけていることを記載します。
- bool値を入れるカラムには`tinyint(1)`を利用する
- 長くない可変文字列を入れる場合（大体1024文字より下くらいかな？）はvarcharを利用する。
- 長い可変文字列を入れる場合はtext型を利用する、またtext型を使う場合はテーブルのROW_FORMATがDynamic(Barracuda)であることを確認する
- MySQL5.6まではデフォルトのフォーマットはCompact(Antelope)でしたが、これは1レコードあたり8KBまでしかデータを入れることができません。
テキスト型を使うと8KB制限を突破してしまうこともあるため、テーブルのフォーマットがDynamic(Barracuda)であることを確認します。
- 整数値を入れる場合はint型かbigint型を使う
- float型は使わない
- 精度のトラブルに巻き込まれたくないためfloatは使いません。多くの場合、doubleかdecimalで問題ありません。
金額情報など、精度を求められる小数値にはdecimalを使う
doubleも小数点以下の精度に悩まされることがあります。金額を扱う、精度が必要な計算は必ずDecimalを利用します。
- 日付を入れる場合はDATE型を使う
- 商品のお届け日など、日付を入れる場合は DatetimeやTimestamp型ではなくDATE型を使うようにします。DatetimeやTimestampはタイムゾーンの影響を受けるためです。
- JSON型を使ったら負け


郵便番号や電話番号のnumberかstringかの悩み
- 算術計算の対象ではないのでstringにする。

## 命名規則
[参考URL](https://qiita.com/genzouw/items/35022fa96c120e67c637)

1. 大文字を利用しない。
テーブル名、カラム名ともに大文字を利用しない。
（DBにより大文字小文字を区別するもの、しないものなどがあるため小文字で統一を図る）

2. 複数単語の連携はスネークケース
テーブル名、カラム名ともにスネークケースを利用する。
キャメルケース、キャメルバックはNG。

## DB・テーブル設計のベストプラクティス
[参考URL](https://neos21.net/tech/design/db-table-practices.html)

## テーブル 複数形 vs 単数形
[参考URL](https://medium.com/@fbnlsr/the-table-naming-dilemma-singular-vs-plural-dc260d90aaff)
[参考URL](https://qiita.com/siinai/items/d4274c95fcdde3fd7295)

実際のところWEB系のフレームワークなどは複数形を好むため、複数形のテーブル名に慣れ親しんでいる人は多い。

## 空文字 or NULL
[参考URL](https://ja.stackoverflow.com/questions/66361/mysql%e3%81%aevarchar-%e3%83%87%e3%83%bc%e3%82%bf%e5%9e%8b%e3%81%ae%e5%88%9d%e6%9c%9f%e5%80%a4%e3%81%a7-null-%e3%81%a8%e7%a9%ba%e6%96%87%e5%ad%97%e3%82%92%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%ab%e4%bd%bf%e3%81%84%e5%88%86%e3%81%91%e3%82%8b%e3%81%b9%e3%81%8d%e3%81%8b)

空文字だと、電話番号を持っているが電話番号がない。というようなよくわからない事情がでる。
そのため持っていないのであれば`NULL`にした方がいいかも。
> データが存在しないのならば、素直にNULLを入れるべきです。



## OAuth2.0のユーザーテーブル設計
[これが分かりやすい](https://zenn.dev/pyhrinezumi/articles/8455f0d61e856f)

## id 設計

主キーは**検索のキー**として利用されたり、他の関係に参照のために格納されたりする確率が高いため、できる限り**データ量の小さい方がよい。**
よって複合キーはあまり適さない。

### uuidで使う
[参考URL](https://zenn.dev/dowanna6/articles/3c84e3818891c3)

メリット
- users/1とかでプライマリキーを連番にすると推測されやすい。スクレイピングされまくる
- 

デメリット
- insertが完了するまでidがわからない。

処理に時間がかかる場合、先にidだけ返して永続化処理は非同期に実施することがときどきありますよね（画像アップロードとか）
こういう時もDB側での採番だと実際DBにinsertするまではidが確定しないので、本当は今この瞬間にinsertする必要がなくても採番するためだけにDBとのI/Oが発生することになります。同時にたくさんのファイルをたくさんのユーザーがアップロードするよ！みたいな機能を作りたい時にちょっとパフォーマンスが心配ですよね

## プライマリキーにULIDを使う
[参考URL](https://zenn.dev/emiksk/articles/e2716c0af75eea)


## 外部キー制約

参照されるのが
親テーブル

参照するのが
子テーブル

## リレーションシップの種類

- 依存リレーションシップ
子テーブルの存在が親に依存している場合

- 非依存リレーションシップ
子テーブルの存在が親に依存していない場合


## 多対多

多対多の関係の場合にどうテーブル設計をすれば良いかわからなくなってしまいがち。
>そうなんです。多対多の関係の場合、どう頑張っても良い設計にならないのです。
ですのでそもそも**多対多の関係にならないような設計が必要**で、その解消方法は**中間テーブルを用意し1対多の関係になるように設計することが必要**

## 論理削除の可否
[twadaさんに語ってもらった](https://fukabori.fm/episode/27)
論理削除はアンチパターンのひとつだが割とよくある設計。
>レコードを消したい。でも消したくないみたいな時に削除フラグ項目を設け、レコードをDELETEするのではなく削除フラグをUPDATEして、SELECTの条件で削除フラグがTRUEなら取得しないようにするやつです。

頻繁に復活させたり、レコード数が少ないテーブルに設けるのであれば検討の余地はありますが、基本的には論理削除を用いないほうが良いでしょう。

## 内部結合と外部結合の違い
[参考URL](https://style.potepan.com/articles/14926.html#SQL)

## チューニング
[LEFT JOINとORDER BY](https://gist.github.com/kano-e/8d75be08037809fd280d/4d9800a5237e17df49027f9a96f092d2e45a7635)

速度低下の原因はSQLが内部的にどのような処理を行っているかを表示させるexplainで見ることができる。

- SQLが遅い場合は、explainである程度遅い原因を確認できる
- 件数が多いテーブルで重い処理が実行されているときは要注意
- なるべくインデックスを使って処理されるよう、order byなどの指定を変えてみる

## ORDER BYで起こること

- ORDER BY使うと全部並べ替えようとする
- ORDER BY使わずにSELECTするのは速いけど、実際の業務では現実的ではない
- インデックス使うのが一般的
- インデックスはソートされているようなものなので、インデックスがあればORDER BYはインデックスを元に行われる

## LEFT JOIN で起こること

LEFT JOINする時、大抵はONでJOINの結合条件を設定する。
FROMに指定した`テーブルA`のレコードが10_000件、JOINに指定したテーブルBのレコードが1_000件あった場合
`テーブルA`のレコードの件数分、`テーブルB`の対象レコードを探す処理が必要になる

これは、最悪の場合10_000_000レコード分の処理になる (10_000 * 1_000)
JOINは掛け合わせなので**元になる情報が大きければ大きいほど、その結果が膨れ上がることになる**
一般的にJOIN遅いって言われているのは、これのせい