# DB

RDB & NoSQLなどDB関連

[学習効率を上げるためのバックエンドのデータベース基礎知識](https://devsakaso.com/about-database-basics/)

[瞬殺でDBを使って何かしたいとき](https://zenn.dev/takuho/articles/efc40344f3122e)
[DockerでサクッとDBからER図を作成する](https://qiita.com/kamukiriri/items/ab1669c19831c18db9ee)

## DB設計の時の考え方

どうせ最初からパーフェクトなテーブル設計はできない。
経験則がいきる。
最初は完璧になんて不可能なので、ある程度考え、実装し、間違っていればまたやり直す。を繰り返すことが一番の近道です。
あ、どうせ変化していくものなので完璧を求めすぎないこともポイントですよ。

## データベース設計の際に気を付けること
[参考URL](https://tech.tabechoku.com/entry/2020/06/15/132518)

1. 制約をつける
データベース設計において重要なのは、いかにして不整合を起こさないようにするか。
「データを引いてみたら関連先のレコードが無くなっている」、「このレコードはユーザーごとに1つだけ持つはずだけど、2レコードある」など。 不整合は往々にして発生する。
データを挿入・更新・削除してもよいかの**チェックはアプリケーションレベルで防ぐだけではなく、可能ならばデータベースレベルで行う。**

そのために、以下制約をつける努力をする。
  1. 外部キー制約をつける
  2. ユニークキー制約をつける




## 設計ツール

ER図を書いていくことになる。

## テーブル 複数形 vs 単数形
[参考URL](https://medium.com/@fbnlsr/the-table-naming-dilemma-singular-vs-plural-dc260d90aaff)
[参考URL](https://qiita.com/siinai/items/d4274c95fcdde3fd7295)

実際のところWEB系のフレームワークなどは複数形を好むため、複数形のテーブル名に慣れ親しんでいる人は多いと思ます。

## OAuth2.0のユーザーテーブル設計
[これが分かりやすい](https://zenn.dev/pyhrinezumi/articles/8455f0d61e856f)


## id 設計

主キーは**検索のキー**として利用されたり、他の関係に参照のために格納されたりする確率が高いため、できる限り**データ量の小さい方がよい。**
よって複合キーはあまり適さない。

### uuidで使う
[参考URL](https://zenn.dev/dowanna6/articles/3c84e3818891c3)

メリット
- users/1とかでプライマリキーを連番にすると推測されやすい。スクレイピングされまくる
- 

デメリット
- insertが完了するまでidがわからない。

処理に時間がかかる場合、先にidだけ返して永続化処理は非同期に実施することがときどきありますよね（画像アップロードとか）
こういう時もDB側での採番だと実際DBにinsertするまではidが確定しないので、本当は今この瞬間にinsertする必要がなくても採番するためだけにDBとのI/Oが発生することになります。同時にたくさんのファイルをたくさんのユーザーがアップロードするよ！みたいな機能を作りたい時にちょっとパフォーマンスが心配ですよね

## プライマリキーにULIDを使う
[参考URL](https://zenn.dev/emiksk/articles/e2716c0af75eea)



## 触る時に考えること

- seedで一気にできないか
- 自動化できないか
- 本番を触る時はすべてエビデンスをとれ（スクショなど）
- 何をしたのかしっかりと伝えられること。そのためのエビデンス
- CRUDの内のC(create)U(update)D(delete)をする前には必ずselectをしろ
- indexは大体どこのSQLでも単一の値にはインデックスが貼られている。
→ しかし複数の値での検索時はインデックスが貼られていないため検索回数が多いのは検討をしインデックスを貼る。

## DBマイグレーション

データベースを削除し手から作り直すと、DBに保存されている情報がすべて削除される。
こういった事態を回避する方法としてデータベースマイグレーションを行う方法がある。
マイグレーションとは、**DBに保存されているデータを保持したままテーブルの作成やカラムの変更などを行うための機能。**
運用中のデータベースにデータを入れたまま、テーブルを追加したりカラムを変更するなどして、スキーマを管理する機能

※対象の言語ORMに対して、マイグレーションがない場合は汎用なマイグレーションツールを使うなど対策が必要

## パスワード保存について

データベースに生の（平文の）パスワードを保存するのは情報セキュリティの観点から望ましくない。
**その代わりにパスワードのハッシュ値を(あるいはダイジェスト)と呼ばれる値をデータベースに保存するのが定石**

## アプリケーションからのDB基本利用法

アプリケーションからDBにアクセスするためにはデータベース固有のプロトコルを用いてアクセスする必要があり、各DB向けに実装されているドライバーを使う。
一方アプリケーション側から呼び出す接続コードは、データベースドライバーの実装に依存しない汎用的なAPI

## DBバックアップについて

ダンプのファイル量が多いと時間がかかる。
そのため、その際にデータの書き換えがあるとデータの相互性が失われる。
そのためデータのバックアップを取得するときは**DBを停止して行うべき**

## DB種類

- キーバリューストア
memcachedやRedis

## DB分割構成

Webアプリケーションの規模が大きくなると応答速度の低下が問題になることがあり、ボトルネックとなるのはDBアクセスに関する部分。
そういった問題を解決し、複数のDBを利用するgemパッケージとしてOctopusなどがあったがRails6.0からはRails標準機能として複数DBへ対応した。

しかし、実際に複数DBとして望まれるケースで多いのは**書き込みと読み込みの負荷を軽減させるために書き込む用のデータベースと、そのデータを同期した読み取り用データベースに分割する構成。**

書き込み用データベースを**プライマリーDB**
レプリケートした読み取り専用データベースを**レプリカDB**


上記の構成の場合、レプリカDBへ直接マイグレーションの適用やデータの書き込みは行わない（RailsではレプリカDBであると明示するため`database.yml`にreplicaを指定する）
実運用ではレプリカDBへの接続は参照権限のみのユーザで接続するのが望ましい。

## リードレプリカ(read replica)

リーどレプリカとは、DBの負荷分散のために作成される**参照専用の複製。**
データの更新＆追加は行わず検索や読みこみのみを行う。
