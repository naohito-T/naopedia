# SQL

SQLの普遍的なものについて記載していく。

## SQLがオンラインでできる
[SQL Fiddle](http://sqlfiddle.com/)
[使い方説明](https://osakanav.com/sql-fiddle)

## チューニング
[WebLogic Server参照から学ぶ](https://docs.oracle.com/cd/F25597_01/document/products/wls/docs92/perform/topten.html#wp1132669)

項目
- プールサイズのチューニング
- プリペアドステートメントキャッシュの使用
- ロギングラストリソースの最適化の使用
- 接続バックログのバッファリングのチューニング
- チャンク サイズのチューニング
- OptimisticまたはRead-only同時方式の使用
- ローカル インタフェースの使用
- eager-relationship-cachingの使用
- HTTPセッションのチューニング
- メッセージング アプリケーションのチューニング

## 生クエリ

生クエリとは、SQLそのままのこと、、？
ORMなどを使用していないとかかな？

## クエリービルダー

ORMとか使っていると、どうしても生のSQLを書きたくなる時がある。
その時はクエリービルダーで検索する

## idについて

[Facebook, Twitter, Instagramなどがどうやって生成しているか](https://qiita.com/daisy1754/items/98a6e6b17d8161eab081)

primary_key : ソートができる。けど何か悪い？
UUID : sortができない。けど秘匿性は上がる。パフォーマンスが少し落ちる
ULID : UUIDの欠点をカバー。ULIDにはタイムスタンプが先頭にある。プライマリキーにUUIDを指定した場合はレコード数が増えていくほど、INSERT時間が増えていくことになる。
※性能劣化は2割程度

昨今ではULIDを使うのが便利かも

>一般のお客さんが使う(ログインやお気に入り)機能を持っているので、ユーザやデータ規模の予測しやすい整数系の id を避けたいという意図です
2台のサーバ運用だと衝突する可能性がある（auto_increment）ため、

## UPSERT
[参考URL](https://blog.officekoma.co.jp/2018/06/postgresqlupdateinsertupsert.html)

データがあればUPDATE、なければINSERTができるやつ。
postgresだと高速。mysqlだと遅いとのこと。

>mysql だとそもそも upsert 周りが弱い (Postgres みたいな conflict target がない) のと primary key として使う ULID の生成を model のレイヤーでやってるせいで import が動かん

## DDL(Data Definition Language) データ定義言語

DDLとは、コンピューターーで用いられる人工言語の分類のひとつで、データを格納するための構造を定義するための言語。

データベースの構造や構成を定義するために用いられるものが多く、単にDDLといった場合には、リレーショナルデータベース（RDB）の制御に用いられるSQL言語の一部の命令群を指すことが多い。

SQLにおけるDDLには、データベースやテーブル、ビューなどの作成を行う**CREATE文**や、削除する**DROP文**、変更を加える**ALTER文**、データを全削除する**TRUNCATE文**などが含まれる。

ここで言いたいのは、
プロジェクトのマイグレーションファイルで管理をするのはDDLまでじゃないの？

## マイグレーション
[リファレンス](https://railsguides.jp/active_record_migrations.html)

マイグレーションファイルはDBへの変更を記述しておくファイル
例として、テーブルを作成したいときや、カラムを追加したい時はマイグレーションファイルを作成する。

マイグレーションファイルはテーブルの中身のカラムを作成するファイル。
**※マイグレーションではRubyのDSLを持っているので生のSQLを作成する必要はない。**
そしてスキーマとスキーマへの変更をDBの種類へ依存せずに済む。

## バルクインサート

バルクインサートとは、RDBのテーブルに行を追加する際、複数の行を1回のSQL文の実行で追加すること。
データベースに対する命令のひとつでありたくさんのデータを、まとめて一気にデータベースに突っ込むときに使う命令
大量のデータを1回の命令でデータベースに入れられる、insert文っぽいやつ

## SQLクエリのN+1問題
[参考URL](https://qiita.com/muroya2355/items/d4eecbe722a8ddb2568b)
[RailsでのN+1問題発見ツール](https://www.techscore.com/blog/2012/12/25/rails%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E7%B4%B9%E4%BB%8B-n1%E5%95%8F%E9%A1%8C%E3%82%92%E6%A4%9C%E5%87%BA%E3%81%99%E3%82%8B%E3%80%8Cbullet%E3%80%8D/)

SQLでの対応策としては2種類ある。
- JOIN句による表の結合
テーブル結合自体に時間がかかるが、1件のクエリ￥で欲しい情報を得られる。

- Eager Loading（必要なデータを事前にロード）
テーブルの取得に1回クエリを発行。
別テーブルから、今後の処理に必要なデータを1回のクエリでまとめて取得。
その後アプリ側で、データの結合を行う。
といった手法です。クエリは2件で済みます。

```sql
-- まずアプリ側に、書籍テーブルの情報をドサッと持ってくる
SELECT * FROM 書籍;
-- 各書籍の借用者IDを格納する配列を作成する
userIDs = [3, 1, 2, 1, 4]
-- よって、利用者テーブルから、IDが [ 3, 1, 2, 1, 4 ] の利用者の情報を取得すれば良さそうとなる。

-- 利用者テーブルから、利用者情報を取得する
SELECT * FROM 利用者 WHERE ID IN (3, 1, 2, 1, 4);
```
これで必要な書籍情報と、利用者情報がすべて取得できました。今後クエリは発行しません。

## SQLアンチパターン
[SQLアンチパターン勉強会　第三回：IDリクワイアド](https://qiita.com/ayayo/items/ba38853bca0c2cc2acb7)

## 論理削除は実用的なのか
[参考URL](https://mr-star.hatenablog.com/entry/RDB%E3%81%AE%E8%AB%96%E7%90%86%E5%89%8A%E9%99%A4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)

論理削除は削除とみなしフラグを立てるだけ。  
問題の本質として**削除という状態をテーブルに持たせてしまっているのがだめ**  

以下の場合は削除フラグを持たせてもいい  
- 対象のテーブルが小さくINDEXが不要
- そのテーブルが関連するテーブルの親になることがなくデータを取得する際にJOINの対象になることがない。
- UNIQUE制約や外部キーが不要

論理削除を使わない場合の対象法としては、削除するデータは別テーブルに移動することが良いと言われている。  
[【テーブル設計】削除フラグを使わず削除テーブルを使うべき](https://yaruki-strong-zero.hatenablog.jp/entry/delete_table_instead_delete_flag)
