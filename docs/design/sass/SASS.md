# sass

css がわかっていないと sass を実施しても意味がない。
css が読み終わってから sass を参照すること。

[個人の有用 sass 記法についてまとめている(初心者)](https://www.webdesignleaves.com/pr/css/css_basic_08.html)
[吉本式 BEM 設計(BEM 設計ベース)(導入時)](https://tsudoi.org/guide/)

```sass


```

## SCSS とは

[以下はこれを参考にして必要なものだけを抜粋している](https://www.webdesignleaves.com/pr/css/css_basic_08.html)

SCSS は Sass の記法のひとつ。
SASS には**記法が 2 つ**ある。Sass 記法と Scss 記法の二つの記法があるが、現在は Scss が主流。

- version 確認
  `$ sass -v`

- コメント、文字コード
  Sass では`css /* */`が使えるが JS などで使用する`js // `のような 1 行コメントも使用ができる
  ※CSS のコメントはコンパイルされても削除され図に残る。

- 文字コードの指定
  コメントなどに日本語を含める場合、ファイルの先頭で@charset を使用して UTF-8 を設定する必要がある。

## 親セレクタの参照 (&)

セレクタに&を使うとネストしている親セレクタを参照することができる。

## 変数 (Variables: $)

Sass の変数では以下のような決まりがある。
変数の宣言は名前$から初め : で区切って値を指定
半角数字から始まる名前や連続したハイフンから始まる名前はエラーになる。
使用方法として
基本のフォントカラーやリンクカラー、ベースフォントなどを予め指定しておくと便利

## Sass でのアンスコとハイフン

Sass の変数名では*(アンダースコア)*(ハイフン)は互換性がある。例として$main-widthと変数を定義すると、その変数を$main_width で参照することができてしまう。どちらかに統一した方が管理がしやすいかもしれない。

## 変数のスコープ

トップレベルの位置で定義した変数はどこでも有効になるが、{}ブラケット内で定義をした変数はブラケット内のみで有効になる。

## Sass のデータタイプ型

Sass には型(データタイプ)が存在し、現在 7 種類に分類されている。

## 演算(Operations)

Sass では四則演算や文字列の連結、色の演算等を行うことができる

## import

通常の CSS の@import が使用可能。また@import の書き方は、Sass と CSS で同じだが、条件によって Sass の@import か CSS の@import かが決まる。

- sass での@import
  Sass の@import はファイル内のどこでも記述することができる
  Sass の場合、インポートした Sass ファイルの中に展開され 1 つの CSS ファイルとして生成される。ただし、この時インポートした Sass ファイルも CSS ファイルとしてコンパイルされてしまい、不要な CSS ファイルが生成されてしまう。
  partial を使うことで回避がされる。

## ファイルの分割(partial)

Sass は分割した Sass ファイルをひとつの CSS ファイルとしてまとめることが可能。
インポートした Sass ファイルはコンパイルすると CSS ファイルとして生成されるが、CSS ファイルとして生成したくない場合は、ファイル名の先頭に\_(アンダースコア)をつけることで、コンパイルしても CSS ファイルを生成しないようにすることができる

> Sass ファイル名の先頭にアンダースコアを付けると、コンパイルしても CSS ファイルが生成されないという仕様があり、この部分的な Sass ファイルまたは機能をパーシャル（partial）と呼びます。
> これにより「Sass ではファイルを分割して管理するが、コンパイル後に生成される CSS ファイルは１つだけ」ということが可能になります。
> partial は、CSS ファイルには変換されないため、最終的に CSS ファイルとして変換したいメインの Sass ファイルから読み込むようにします。

## パーシャル(partial)のインポート

パーシャルを読み込む(インポートする)場合は、拡張子とアンダーバーを省略することができる(拡張子やアンダーバーをつけたままでも問題はない)

## パーシェルを使ったディレクトリ構成/ファイル構成

project
|\_css/
| |- style.css（生成される CSS）
|
 |\_sass/
|- \_reset.scss（リセット用）
|- \_extend.scss（@extend の定義）
|- \_mixin.scss（@mixin の定義）
|- \_settings.scss（変数などの設定の定義）
|- style.scss（メインのスタイルと各 Sass ファイルのインポート用）

## ミックスイン @mixin

> ミックスインを使うとプロパティやセレクタをまとめてワンセットにしておいて、それらを読み込むことができます。
> ミックスインは @mixin ディレクティブを用いて定義し、@include ディレクティブで定義したミックスインを呼び出します。
> ミックスインは、@include で挿入した箇所で展開されるコード片で、ミックスイン自体のコードは CSS としてコンパイルされず、@include されてはじめて実体を持ちます。
> そのため、よく使うものを一通りライブラリとして読み込んでおいて必要に応じて呼び出す、という使い方が可能です。
> ミックスインもスコープを持つので、ルールセット内で定義するとその中でしか利用できません。
> またミックスインでは引数を取ることができるので、より使い回しが柔軟にできます。


## @mixin と @extend と @fucntion のコンパイル違い

[参考URL](https://www.monster-dive.com/blog/web_creative/20140222_000132.php)

- extend

```scss
.hoge1 {
    margin:10px 0;
    padding:5px;
}
.hoge2{
  @extend .hoge1;
  padding:0;
}
```

↓にコンパイルされる

```css
.hoge1, .hoge2 {
  margin: 10px 0;
  padding: 5px;
}
.hoge2 {
  padding: 0;
}
```

@extendで呼ばれたhoge1の中身がごそっとhoge2にも反映されています。
これだけを見ると、1か所で書けるものを2か所にわけて書くのは非効率！と思うかもしれないですが、1つのクラス内で複数回@extendすることもできますし、@extendしているクラスを@extendすることもできますので、使い方次第で絶大な効果を発揮してくれます。

- mixin
mixinは、extendとの大きな違いは2つあると思います。細かくはいっぱいあるのですが。
extendと違いグルーピングされない
extendの例と同じ内容をmixinで書くと一目瞭然です。

```scss
@mixin hoge {
    margin:10px 0;
    padding:5px;
}
.hoge1{
  @include hoge;
}
.hoge2{
  @include hoge;
  padding:0;
}
```

↓にコンパイルされる

```css
.hoge1 {
  margin: 10px 0;
  padding: 5px;
}
.hoge2 {
  margin: 10px 0;
  padding: 5px;
  padding: 0;
}
```

となります。
extendで書き出されたCSSと内容は同じなのですが、「.hoge1, .hoge2 {}」のようにグルーピングされません。
この違いだけですと、extendのほうがソースも短くなるのでいいかと思いますが、制作会社がベースをSassで作って、日々の更新はクライアント企業の担当者がCSSファイルを触るサイトなどでは、分けて書き出したほうが良い場合もあるかもしれません。

extendと違い引数（パラメータ）を渡すことができる
こちらがミックスインを使う最大の理由になるかと思います。説明するよりも例を見たほうが早いと思いますので、早速書いてみます。

- function

最後にfunctionですが、引数などの扱いはmixinと一緒ですが、返すものが値となります。簡単な例ですがファイル名を引数で渡してurlをセットするfunctionは下記になります。

```scss
$hoge:'img/';
$png:'.png';
@function urlPng($fileName) {
  @return url($hoge+$fileName+$png);
}
.hoge1 {
  background:urlPng('test');
}
.hoge2 {
  background:url($hoge+'test'+$png);
}
```

↓にコンパイルされる

```css
.hoge1 {
  background: url("img/test.png");
}
.hoge2 {
  background: url("img/test.png");
}
```

と「.hoge1」も「.hoge2」も同じになります。「.hoge2」のように直接四則演算を行ったりしてもいいのですが、functionを作ってあげたほうが美しいですね。

## Sassの実行環境

実行環境は3つある

**Ruby Sass**
一番最初に作られたRubyベースののSassの実行環境。2019年3月に公式のサポートは終了していますが、1年くらい前に「使用率約10%」というアンケート結果を見かけたことがあるので、まだ使用している現場もそれなりにあるのかなと思います。

**LibSass**
まだまだ多くの現場で現役で使われているであろうC/C++ベースの実行環境。Node環境でよく使われているnode-sassはLibSassをベースに作られているので、LibSassだと意識せずに使っている人もいるかもしれません。

LibSass非推奨問題
もともと @importが段階的に廃止となるという話もあり、公式としてはLibSassではなくDart Sassを使うことを推奨している、ということは数年前から言われていました。そういった中で、2020年10月に唐突にLibSassが非推奨となりました。

**Dart Sass**
Dart言語で書かれた最新の実行環境。現在の公式推奨環境で、今後廃止予定の @import の代替となる @use や @forwordが唯一使える環境です。


